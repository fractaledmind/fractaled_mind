<!doctype html>
<html lang="en">
  <head>
  <!-- Metadata declarations -->
  <meta charset="utf-8" />
  <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Content declarations -->
  <title>Fractaled Mind</title>
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="feed.xml" />

  <!-- External Resources -->
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js" ></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  <!-- Internal Resources -->
  <link href="../../stylesheets/main.css" rel="stylesheet" type="text/css" />
  <link href="../../images/favicon.png" rel="icon" type="image/png" />
  <script src="../../javascripts/bigfoot.js" type="text/javascript"></script>
  <script src="../../javascripts/search.js" type="text/javascript"></script>

  <!-- Bigfoot.js Popover Footnotes -->
  <script type="text/javascript">
    $(document).ready(function(){
      $.bigfoot({
        numberResetSelector: ".card",
        activateCallback: function($popover, $button) {
          if (MathJax && !$button.data('mathjax-processed')) {
            var content_wrapper = $popover.find('.bigfoot-footnote__content')[0];
            MathJax.Hub.Queue(['Typeset', MathJax.Hub, content_wrapper]);
            MathJax.Hub.Queue(function () {
              $button.attr('data-bigfoot-footnote', content_wrapper.innerHTML);
              $button.data('mathjax-processed', true);
            });
          }
        }
      });
    });
  </script>

  <!-- Responsive Tables -->
  <script type="text/javascript">
    $(document).ready(function(){
      $("td").each(function() {
        var $th = $(this).closest('table').find('th').eq($(this).index());
        $(this).attr('data-th', $th.text());
      });
    });
  </script>

  <!-- Scroll-Fix sidebar
  <script type="text/javascript">
    $(window).on("scroll", function(e) {
      var scroll = $(this).scrollTop();
      var logo_height = $('#site-logo').height();
      var nav_height = $('.navigation').height() + 16;

      if (scroll > logo_height) {
        $('.navigation').css({'position': 'fixed'});
         $('#sidebar').css({
           'position': 'fixed',
           'top': nav_height
         });
      } else {
        $('.navigation').css({'position': 'inherit'});
        $('#sidebar').css({'position': 'inherit'});
      }
    });
  </script>
  -->

</head>


  <body>
    <header>
  <div id="site-logo">
    <a href="/" class="no-hvr">
      <img alt="Fractaled Mind" src="../../images/logo.svg" />
    </a>
  </div>

  <ul id="social-networks">
    <li>
      <a href="https://facebook.com/fractaledmind" class="no-hvr">
        <i class="fa fa-facebook fa-lg"></i>
      </a>
    </li>
    <li>
      <a href="https://twitter.com/fractaledmind" class="no-hvr">
        <i class="fa fa-twitter fa-lg"></i>
      </a>
    </li>
    <li>
      <a href="https://github.com/fractaledmind" class="no-hvr">
        <i class="fa fa-github fa-lg"></i>
      </a>
    </li>
    <li>
      <a href="mailto:stephen@fractaledmind.com" class="no-hvr">
        <i class="fa fa-envelope fa-lg"></i>
      </a>
    </li>
    <li>
      <a href="/feed.xml" class="no-hvr">
        <i class="fa fa-rss fa-lg"></i>
      </a>
    </li>
  </ul>
</header>


    <div class="navigation">
  <nav role="navigation">
    <ul class="navigation-menu">
      <li class="nav-link"><a href="../">articles</a></li>
      <li class="nav-link"><a href="../../projects/">projects</a></li>
      <li class="nav-link"><a href="../../jots/">jots</a></li>
      <li class="nav-link"><a href="../../essays/">essays</a></li>
    </ul>
  </nav>

  <div id="search">
    <div class="searchbar">
      <form role="search" action="/search" method="get">
        <input class="search-term" type="search" placeholder="Search..." name="q" />
        <button class="search-submit" type="submit">
          <img src="https://raw.githubusercontent.com/thoughtbot/refills/master/source/images/search-icon-black.png" alt="Search Icon">
        </button>
      </form>
    </div>
  </div>
</div>


    <div id="main" role="main">
      <div class="card" id="project-page">

    <ul class="card-tags">
      <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="ruby-tag" href="/topics/ruby/">ruby</a>
            <a class="interpreter-tag" href="/topics/interpreter/">interpreter</a>
      </li>
      <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="epistemology-tag" href="/topics/epistemology/">epistemology</a>
            <a class="logic-tag" href="/topics/logic/">logic</a>
      </li>
  </ul>


  <!-- if item has tags, add filler element -->
  <div id="tag-filler-space"></div>


  

  <h2 id="title"><p>Building an Interpreter for Propositional Logic</p>
</h2>

  <hr class="fractal">

  <div id="description"><p>In the <a href="">first post</a> in this series, we built an interpreter to work with a basic subset of propositional logic. In this post, we are going to extend that interpreter to handle the full range of valid expressions in classical propositional logic. Specifically, this means we are going to allow for</p>

<ul>
  <li>handling stacked negation operators (e.g. <code>~~T</code>),</li>
  <li>parentheses to group sub-expressions (e.g. <code>~(T v F) &amp; T</code>),</li>
  <li>multiple binary operators to be used in one expression (e.g. <code>T &amp; F v T</code>), and</li>
  <li>handling the proper operator precedence of the logical operators</li>
</ul>

<p>These additions will give our interpreter the capability to evaluate any properly formed expression of classical propositional logic.<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></p>

<hr />

<h3 id="stacked-negations">Stacked Negations</h3>

<p>The simplest addition to make will be the stacked negation operators. When we left our grammar, the <code>formula</code> rule was like so:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>formula :: (NOT)? term
</pre></td></tr></tbody></table>
</div>

<p>The <code>?</code> meant that a <code>:NOT</code> token could be present before a <code>term</code> zero or one times. We want to allow the <code>:NOT</code> token to present zero or many times. How might we accomplish this? Well, what precisely can be negated? Is it simply a term (e.g. <code>T</code> or <code>F</code>)? No. We are saying that an expression of the form <code>~~T</code> is valid. What is the abstract syntax tree of this expression? It is a negation operator whose operand is … another negation operator, but this operator has a term operand.</p>

<div class="tree">
  <ul>
    <li>
      <a href="#" class="monospace bg-lightgrey font-1em bold">~</a>
      <ul>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">~</a>
          <ul>
            <li>
              <a href="#" class="monospace bg-lightgrey font-1em bold">T</a>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<p>When we start thinking about what this expression is actually encoding, we should see that a negation operator is not necessarily followed by a term; it is followed by a <em>formula</em>. But a logical formula (that is, a subexpression) can also have no negation operator and simply be either a <code>:TRUE</code> token or a <code>:FALSE</code> token (aka a <code>term</code>):</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>formula :: (NOT)* formula | term
</pre></td></tr></tbody></table>
</div>

<p>In order to encode this new <code>formula</code> rule in our parser, we need simply to change what we pass into the creation of the <code>AST::Negation</code> object:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>

  <span class="c1"># formula :: (NOT)* formula | term</span>
  <span class="k">def</span> <span class="nf">formula</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:NOT</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:NOT</span><span class="p">)</span>
      <span class="k">return</span> <span class="no">AST</span><span class="o">::</span><span class="no">Negation</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">term</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>We can add some tests to the <code>run_tests</code> method we defined in the last post to ensure that this new method is working properly:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">run_tests</span>
  <span class="c1"># ...</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~~T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~~~F'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~~F &amp; F'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'F v ~~T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<blockquote>
  <p>You can find the script we have built to this point in <a href="https://gist.github.com/fractaledmind/a072674b18086fdebf3b3a535c0f7dfb/d31ab892cc29ee6814d61270f3ecd32c3ddb51e1">this revision of this Gist</a></p>
</blockquote>

<hr />

<h3 id="parenthetical-grouping">Parenthetical Grouping</h3>

<p>Just like in arithmetic, expressions in propositional logic can use parentheses to explicitly create sub-expressions. When parentheses are used in this way, it is explicitly encoding that the grouped sub-expression has higher precedence than the rest of the expression.</p>

<p>The first step in allowing for this feature is to update our <code>Lexer</code> to create the appropriate tokens for these characters:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Lexer</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">tokens</span>
    <span class="vi">@input</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">''</span><span class="p">).</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">char</span><span class="o">|</span>
      <span class="c1"># for each `char`, there are only 6 possible things to do</span>
      <span class="k">case</span> <span class="n">char</span>
      <span class="k">when</span> <span class="s1">' '</span>
        <span class="k">next</span>
      <span class="k">when</span> <span class="s1">'~'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:NOT</span><span class="p">,</span> <span class="s1">'~'</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'&amp;'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:AND</span><span class="p">,</span> <span class="s1">'&amp;'</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'v'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:OR</span><span class="p">,</span> <span class="s1">'v'</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'&gt;'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:IFSO</span><span class="p">,</span> <span class="s1">'&gt;'</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'('</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:LPAREN</span><span class="p">,</span> <span class="s1">'('</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">')'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:RPAREN</span><span class="p">,</span> <span class="s1">')'</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'T'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:TRUE</span><span class="p">,</span> <span class="s1">'T'</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'F'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:FALSE</span><span class="p">,</span> <span class="s1">'F'</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">compact</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Next, we need to update our grammar to allow for such grouped sub-expressions.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>expression :: formula ((AND | OR | IFSO) formula)*
formula :: (NOT)* formula | LPAREN expression RPAREN | term
term :: TRUE | FALSE 
</pre></td></tr></tbody></table>
</div>

<p>We say that an <code>expression</code> comes between parenthese, and not a <code>formula</code>, because expressions of the form <code>~(T v F)</code> are valid.</p>

<p>So, we need to update the <code>Parser#formula</code> method to handle this case:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>

  <span class="c1"># formula :: (NOT)* formula | LPAREN expression RPAREN | term</span>
  <span class="k">def</span> <span class="nf">formula</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:NOT</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:NOT</span><span class="p">)</span>
      <span class="k">return</span> <span class="no">AST</span><span class="o">::</span><span class="no">Negation</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:LPAREN</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:LPAREN</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">expression</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:RPAREN</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">term</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Let’s add some more tests to the <code>run_tests</code> method to ensure that this new feature is working properly as well:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">run_tests</span>
  <span class="c1"># ...</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'T &amp; (F v T)'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~(T &amp; (F v T))'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~(T &amp; (F v T)) &gt; T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<blockquote>
  <p>You can find the script we have built to this point in <a href="https://gist.github.com/fractaledmind/a072674b18086fdebf3b3a535c0f7dfb/0b65125d6727f09373a125fa2f18ffd65ce759a8">this revision of this Gist</a></p>
</blockquote>

<hr />

<h3 id="multiple-binary-operators">Multiple Binary Operators</h3>

<p>Our current <code>Parser</code> does not properly handle expressions with multiple binary operators. As it is, if we were to parse the expression <code>T &amp; F v T</code>, we would get an abstract syntax tree of this shape:</p>

<div class="tree">
  <ul>
    <li>
      <a href="#" class="monospace bg-lightgrey font-1em bold">&amp;</a>
      <ul>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">T</a>
        </li>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">F</a>
        </li>
      </ul>
    </li>
  </ul>
</div>

<p>The disjunction is completely ignored! Before we can fix this, we must first determine why and where this is happening. Well, we know that we handle parsing binary operators in the <code>Parser#expression</code> method, so let’s start looking there:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>

  <span class="c1"># expression : formula ((AND | OR | IFSO) formula)?</span>
  <span class="k">def</span> <span class="nf">expression</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">formula</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:AND</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:AND</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Conjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:OR</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:OR</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Disjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:IFSO</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:IFSO</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Implication</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">result</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>What we find is that we don’t allow for recursive expressions; that is, if a formula is followed by an operator, we presume that the right hand operand is also a formula. In order to allow for complex expressions, we need to update a grammar to:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>expression : formula ((AND | OR | IFSO) expression)*
</pre></td></tr></tbody></table>
</div>

<p>This allows for recursive expressions. And, to encode that in our method, we simply replace the <code>formula</code> param passed to the AST operator intializers with a recursive call to <code>expression</code>:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>

  <span class="c1"># expression : formula ((AND | OR | IFSO) expression)*</span>
  <span class="k">def</span> <span class="nf">expression</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">formula</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:AND</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:AND</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Conjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:OR</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:OR</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Disjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:IFSO</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:IFSO</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Implication</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">result</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>We can add a couple more tests to ensure that our change is doing what we expect:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">run_tests</span>
  <span class="c1"># ...</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'T &amp; F v T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'F &amp; T v T'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~T &amp; F v T'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~F &amp; T v T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<blockquote>
  <p>You can find the script we have built to this point in <a href="https://gist.github.com/fractaledmind/a072674b18086fdebf3b3a535c0f7dfb/e61a5a1b8339119e3e8b75d141282e0b15ac37f1">this revision of this Gist</a></p>
</blockquote>

<hr />

<h3 id="operator-precedence">Operator Precedence</h3>

<p>The final issue we have with our interpreter is that is doesn’t properly handle the precedence of the logical operators. Operator precedence describes the order of operations in an expression. In arithmetic, I remember learning this mnemonic to remember the order of operations: “Please excuse my dear aunt Sally”. This is an acronym mnemonic for “Parentheses exponentiation multiplication division addition substraction”, or, to put it in tabular form:</p>

<table class="tables">
  <thead>
    <tr>
      <th style="text-align: center">Operator</th>
      <th style="text-align: center">Precedence</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code>^</code></td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>*</code></td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>/</code></td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>+</code></td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>-</code></td>
      <td style="text-align: center">3</td>
    </tr>
  </tbody>
</table>

<p>This order of operations says that the arithmetic expression <code>1^2 * 3 / 4 + 5 - 6</code> should be evaluated as <code>((((1^2) * 3) / 4) + 5) - 6</code>. So, operator precedence tells our interpreter what order to evaluate the operations in. Should it evaluate the multiplication before the addition, or vice versa?</p>

<p>In propositional logic, the operator precedence is “negation conjunction disjunction implication”:</p>

<table class="tables">
  <thead>
    <tr>
      <th style="text-align: center">Operator</th>
      <th style="text-align: center">Precedence</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code>~</code></td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>&amp;</code></td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>v</code></td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>&gt;</code></td>
      <td style="text-align: center">4</td>
    </tr>
  </tbody>
</table>

<p>So, let’s look back at one of the tests we added for handling multiple binary operators:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'F &amp; T v T'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
</pre></td></tr></tbody></table>
</div>

<p>Given the operator precedence, how should <code>F &amp; T v T</code> be understood? Since conjunction (<code>&amp;</code>) has a higher precedence than disjunction (<code>v</code>), it should be read as <code>(F &amp; T) v T</code>, which would evaluate as <code>true</code>; however, we can see that our test expects it to be <code>false</code>. If you have been running the code as we have gone along, step by step, you would have seen your tests pass. This is because our interpreter has no sense of operator precedence and so evaluates the expression from left to right (e.g., in this case, it reads that expression as <code>F &amp; (T v T)</code>).</p>

<p>We need to encode the precedence of our operators, but how do we do so?</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>I say “classical propositional logic” because modern propositional logic has many more valid operators. But this is an addition we will get to in the next post. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>
</div>

    </div>

    <aside id="sidebar">

  <hr class="fractal">

  <div id="recent-articles">
    <h5>Recent Posts</h5>
    <ul class="fa-ul">
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="./">Building an Interpreter for Propositional Logic</a>
        </li>
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../ruby-logic-interpreter-1/">Building an Interpreter for Propositional Logic</a>
        </li>
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../death-of-self/">Death of Self</a>
        </li>
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../the-word-of-god/">The Word of God</a>
        </li>
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../on-antinomies-and-paradoxes/">On Antinomies and Paradoxes</a>
        </li>
    </ul>
  </div>

  <hr class="fractal">

  <div id="all-tags">
    <h5><a href="../../topics/">Topics</a></h5>
    <ul class="list-none">
      <!-- Add all Article tags -->
        <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="epistemology-tag" href="/topics/epistemology/">epistemology</a>
            <a class="math-tag" href="/topics/math/">math</a>
        </li>
        <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="epistemology-tag" href="/topics/epistemology/">epistemology</a>
            <a class="logic-tag" href="/topics/logic/">logic</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="pdf-workflow-tag" href="/topics/pdf-workflow/">pdf-workflow</a>
        </li>
        <li class="breadcrumb">
            <a class="prose-tag" href="/topics/prose/">prose</a>
            <a class="self-tag" href="/topics/self/">self</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="ruby-tag" href="/topics/ruby/">ruby</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="rails-tag" href="/topics/rails/">rails</a>
        </li>
        <li class="breadcrumb">
            <a class="poetry-tag" href="/topics/poetry/">poetry</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="algorithms-tag" href="/topics/algorithms/">algorithms</a>
        </li>
        <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="faith-tag" href="/topics/faith/">faith</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="git-tag" href="/topics/git/">git</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="git-tag" href="/topics/git/">git</a>
        </li>
        <li class="breadcrumb">
            <a class="prose-tag" href="/topics/prose/">prose</a>
            <a class="relationships-tag" href="/topics/relationships/">relationships</a>
        </li>
        <li class="breadcrumb">
            <a class="poetry-tag" href="/topics/poetry/">poetry</a>
            <a class="relationships-tag" href="/topics/relationships/">relationships</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="css-tag" href="/topics/css/">css</a>
        </li>
        <li class="breadcrumb">
            <a class="prose-tag" href="/topics/prose/">prose</a>
            <a class="life-tag" href="/topics/life/">life</a>
        </li>
        <li class="breadcrumb">
            <a class="prose-tag" href="/topics/prose/">prose</a>
            <a class="faith-tag" href="/topics/faith/">faith</a>
        </li>
        <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="ethics-tag" href="/topics/ethics/">ethics</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="ruby-tag" href="/topics/ruby/">ruby</a>
            <a class="interpreter-tag" href="/topics/interpreter/">interpreter</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="interpreter-tag" href="/topics/interpreter/">interpreter</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="latin-tag" href="/topics/latin/">latin</a>
            <a class="vergil-tag" href="/topics/vergil/">vergil</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="epicurus-tag" href="/topics/epicurus/">epicurus</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="aristotle-tag" href="/topics/aristotle/">aristotle</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="latin-tag" href="/topics/latin/">latin</a>
            <a class="horace-tag" href="/topics/horace/">horace</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="modern-tag" href="/topics/modern/">modern</a>
            <a class="lewis-tag" href="/topics/lewis/">lewis</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="modern-tag" href="/topics/modern/">modern</a>
            <a class="barfield-tag" href="/topics/barfield/">barfield</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="herodotus-tag" href="/topics/herodotus/">herodotus</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="hippocrates-tag" href="/topics/hippocrates/">hippocrates</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="plato-tag" href="/topics/plato/">plato</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="modern-tag" href="/topics/modern/">modern</a>
            <a class="saussure-tag" href="/topics/saussure/">saussure</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="alfred-tag" href="/topics/alfred/">alfred</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="bash-tag" href="/topics/bash/">bash</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="python-tag" href="/topics/python/">python</a>
        </li>
    </ul>
  </div>
</aside>


    <footer role="contentinfo">
  <div class="footer-info">
    <p>&copy; Copyright 2015 by Stephen Margheim</p>
    <p>Powered by <a href="https://middlemanapp.com">Middleman</a>.</p>
  </div>
</footer>


  </body>
</html>
