<!doctype html>
<html lang="en">
  <head>
  <!-- Metadata declarations -->
  <meta charset="utf-8" />
  <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Content declarations -->
  <title>Fractaled Mind</title>
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="feed.xml" />

  <!-- External Resources -->
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js" ></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  <!-- Internal Resources -->
  <link href="../../stylesheets/main.css" rel="stylesheet" type="text/css" />
  <link href="../../images/favicon.png" rel="icon" type="image/png" />
  <script src="../../javascripts/bigfoot.js" type="text/javascript"></script>
  <script src="../../javascripts/search.js" type="text/javascript"></script>

  <!-- Bigfoot.js Popover Footnotes -->
  <script type="text/javascript">
    $(document).ready(function(){
      $.bigfoot({
        numberResetSelector: ".card",
        activateCallback: function($popover, $button) {
          if (MathJax && !$button.data('mathjax-processed')) {
            var content_wrapper = $popover.find('.bigfoot-footnote__content')[0];
            MathJax.Hub.Queue(['Typeset', MathJax.Hub, content_wrapper]);
            MathJax.Hub.Queue(function () {
              $button.attr('data-bigfoot-footnote', content_wrapper.innerHTML);
              $button.data('mathjax-processed', true);
            });
          }
        }
      });
    });
  </script>

  <!-- Responsive Tables -->
  <script type="text/javascript">
    $(document).ready(function(){
      $("td").each(function() {
        var $th = $(this).closest('table').find('th').eq($(this).index());
        $(this).attr('data-th', $th.text());
      });
    });
  </script>

  <!-- Scroll-Fix sidebar
  <script type="text/javascript">
    $(window).on("scroll", function(e) {
      var scroll = $(this).scrollTop();
      var logo_height = $('#site-logo').height();
      var nav_height = $('.navigation').height() + 16;

      if (scroll > logo_height) {
        $('.navigation').css({'position': 'fixed'});
         $('#sidebar').css({
           'position': 'fixed',
           'top': nav_height
         });
      } else {
        $('.navigation').css({'position': 'inherit'});
        $('#sidebar').css({'position': 'inherit'});
      }
    });
  </script>
  -->

</head>


  <body>
    <header>
  <div id="site-logo">
    <a href="/" class="no-hvr">
      <img alt="Fractaled Mind" src="../../images/logo-single-line.svg" />
    </a>
  </div>
</header>


    <div class="navigation">
  <ul id="social-networks">
    <li>
      <a href="https://facebook.com/fractaledmind" class="no-hvr">
        <i class="fa fa-facebook fa-lg"></i>
      </a>
    </li>
    <li>
      <a href="https://twitter.com/fractaledmind" class="no-hvr">
        <i class="fa fa-twitter fa-lg"></i>
      </a>
    </li>
    <li>
      <a href="https://github.com/fractaledmind" class="no-hvr">
        <i class="fa fa-github fa-lg"></i>
      </a>
    </li>
    <li>
      <a href="mailto:stephen@fractaledmind.com" class="no-hvr">
        <i class="fa fa-envelope fa-lg"></i>
      </a>
    </li>
    <li>
      <a href="/feed.xml" class="no-hvr">
        <i class="fa fa-rss fa-lg"></i>
      </a>
    </li>
  </ul>

  <nav role="navigation">
    <ul class="navigation-menu">
      <li class="nav-link"><a href="../">articles</a></li>
      <li class="nav-link"><a href="../../projects/">projects</a></li>
      <li class="nav-link"><a href="../../jots/">jots</a></li>
      <li class="nav-link"><a href="../../essays/">essays</a></li>
    </ul>
  </nav>

  <div id="search">
    <div class="searchbar">
      <form role="search" action="/search" method="get">
        <input class="search-term" type="search" placeholder="Search..." name="q" />
        <button class="search-submit" type="submit">
          <img src="https://raw.githubusercontent.com/thoughtbot/refills/master/source/images/search-icon-black.png" alt="Search Icon">
        </button>
      </form>
    </div>
  </div>
</div>


    <div id="main" role="main">
      <div class="card" id="project-page">

    <ul class="card-tags">
      <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="ruby-tag" href="/topics/ruby/">ruby</a>
            <a class="interpreter-tag" href="/topics/interpreter/">interpreter</a>
      </li>
      <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="epistemology-tag" href="/topics/epistemology/">epistemology</a>
            <a class="logic-tag" href="/topics/logic/">logic</a>
      </li>
      <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="interpreter-tag" href="/topics/interpreter/">interpreter</a>
      </li>
  </ul>


  <!-- if item has tags, add filler element -->
  <div id="tag-filler-space"></div>


  

  <h2 id="title"><p>Building an Interpreter for Propositional Logic</p>
</h2>

  <hr class="fractal">

  <div id="description"><p>In the <a href="http://fractaledmind.com/articles/ruby-logic-interpreter-1/">first post</a> of this series, we built an interpreter to work with a basic subset of propositional logic. In this post, we are going to extend that interpreter to handle the full range of valid expressions in classical propositional logic. Specifically, this means we are going to allow for</p>

<ul>
  <li>handling stacked negation operators (e.g. <code>~~T</code>),</li>
  <li>parentheses to group sub-expressions (e.g. <code>~(T v F) &amp; T</code>),</li>
  <li>multiple binary operators to be used in one expression (e.g. <code>T &amp; F v T</code>), and</li>
  <li>handling the proper operator precedence of the logical operators</li>
</ul>

<p>These additions will give our interpreter the capability to evaluate any properly formed expression of classical propositional logic.<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></p>

<hr />

<h3 id="stacked-negations">Stacked Negations</h3>

<p>The simplest addition to make will be the stacked negation operators. When we left our grammar, the <code>formula</code> rule was like so:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>formula :: (NOT)? term
</pre></td></tr></tbody></table>
</div>

<p>The <code>?</code> meant that a <code>:NOT</code> token could be present before a <code>term</code> zero or one times. We want to allow the <code>:NOT</code> token to present zero or <em>many</em> times. How might we accomplish this? Well, what precisely can be negated? Is it simply a term (e.g. <code>T</code> or <code>F</code>)? No. We are saying that an expression of the form <code>~~T</code> is valid. What is the abstract syntax tree of this expression? It is a negation operator whose operand is … another negation operator, but this operator has a term operand.</p>

<div class="tree">
  <ul>
    <li>
      <a href="#" class="monospace bg-lightgrey font-1em bold">~</a>
      <ul>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">~</a>
          <ul>
            <li>
              <a href="#" class="monospace bg-lightgrey font-1em bold">T</a>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<p>When we start thinking about what this expression is actually encoding, we should see that a negation operator is not necessarily followed by a term; it is followed by a <em>formula</em>. But a logical formula (that is, a subexpression) can also have no negation operator and simply be either a <code>:TRUE</code> token or a <code>:FALSE</code> token (aka a <code>term</code>):</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>formula :: (NOT)* formula | term
</pre></td></tr></tbody></table>
</div>

<p>In order to encode this new <code>formula</code> rule in our parser, we need simply to change what we pass into the creation of the <code>AST::Negation</code> object:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>

  <span class="c1"># formula :: (NOT)* formula | term</span>
  <span class="k">def</span> <span class="nf">formula</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:NOT</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:NOT</span><span class="p">)</span>
      <span class="k">return</span> <span class="no">AST</span><span class="o">::</span><span class="no">Negation</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">term</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>We can add some tests to the <code>run_tests</code> method we defined in the last post to ensure that this new method is working properly:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">run_tests</span>
  <span class="c1"># ...</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~~T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~~~F'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~~F &amp; F'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'F v ~~T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<blockquote>
  <p>You can find the script we have built to this point in <a href="https://gist.github.com/fractaledmind/a072674b18086fdebf3b3a535c0f7dfb/d31ab892cc29ee6814d61270f3ecd32c3ddb51e1">this revision of this Gist</a></p>
</blockquote>

<hr />

<h3 id="parenthetical-grouping">Parenthetical Grouping</h3>

<p>Just like in arithmetic, expressions in propositional logic can use parentheses to explicitly create sub-expressions. When parentheses are used in this way, it is explicitly encoding that the grouped sub-expression has higher precedence than the rest of the expression.</p>

<p>The first step in allowing for this feature is to update our <code>Lexer</code> to create the appropriate tokens for these characters:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Lexer</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">tokens</span>
    <span class="vi">@input</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">''</span><span class="p">).</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">char</span><span class="o">|</span>
      <span class="c1"># for each `char`, there are only 6 possible things to do</span>
      <span class="k">case</span> <span class="n">char</span>
      <span class="k">when</span> <span class="s1">' '</span>
        <span class="k">next</span>
      <span class="k">when</span> <span class="s1">'~'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:NOT</span><span class="p">,</span> <span class="s1">'~'</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'&amp;'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:AND</span><span class="p">,</span> <span class="s1">'&amp;'</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'v'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:OR</span><span class="p">,</span> <span class="s1">'v'</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'&gt;'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:IFSO</span><span class="p">,</span> <span class="s1">'&gt;'</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'('</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:LPAREN</span><span class="p">,</span> <span class="s1">'('</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">')'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:RPAREN</span><span class="p">,</span> <span class="s1">')'</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'T'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:TRUE</span><span class="p">,</span> <span class="s1">'T'</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'F'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:FALSE</span><span class="p">,</span> <span class="s1">'F'</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">compact</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Next, we need to update our grammar to allow for such grouped sub-expressions.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>expression :: formula ((AND | OR | IFSO) formula)*
formula :: (NOT)* formula | LPAREN expression RPAREN | term
term :: TRUE | FALSE 
</pre></td></tr></tbody></table>
</div>

<p>We say that an <code>expression</code> comes between parenthese, and not a <code>formula</code>, because any valid logical expression can be placed between parens, not just a negation operation or a term.</p>

<p>So, we need to update the <code>Parser#formula</code> method to handle this case:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>

  <span class="c1"># formula :: (NOT)* formula | LPAREN expression RPAREN | term</span>
  <span class="k">def</span> <span class="nf">formula</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:NOT</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:NOT</span><span class="p">)</span>
      <span class="k">return</span> <span class="no">AST</span><span class="o">::</span><span class="no">Negation</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:LPAREN</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:LPAREN</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">expression</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:RPAREN</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">term</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Let’s add some more tests to the <code>run_tests</code> method to ensure that this new feature is working properly as well:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">run_tests</span>
  <span class="c1"># ...</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'T &amp; (F v T)'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~(T &amp; (F v T))'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~(T &amp; (F v T)) &gt; T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<blockquote>
  <p>You can find the script we have built to this point in <a href="https://gist.github.com/fractaledmind/a072674b18086fdebf3b3a535c0f7dfb/0b65125d6727f09373a125fa2f18ffd65ce759a8">this revision of this Gist</a></p>
</blockquote>

<hr />

<h3 id="multiple-binary-operators">Multiple Binary Operators</h3>

<p>Our current <code>Parser</code> does not properly handle expressions with multiple binary operators. As it is, if we were to parse the expression <code>T &amp; F v T</code>, we would get an abstract syntax tree of this shape:</p>

<div class="tree">
  <ul>
    <li>
      <a href="#" class="monospace bg-lightgrey font-1em bold">&amp;</a>
      <ul>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">T</a>
        </li>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">F</a>
        </li>
      </ul>
    </li>
  </ul>
</div>

<p>The disjunction is completely ignored! Before we can fix this, we must first determine why and where this is happening. Well, we know that we handle parsing binary operators in the <code>Parser#expression</code> method, so let’s start looking there:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>

  <span class="c1"># expression :: formula ((AND | OR | IFSO) formula)?</span>
  <span class="k">def</span> <span class="nf">expression</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">formula</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:AND</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:AND</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Conjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:OR</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:OR</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Disjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:IFSO</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:IFSO</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Implication</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">result</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>What we find is that we don’t allow for recursive expressions; that is, if a formula is followed by an operator, we presume that the right hand operand is also a formula. In order to allow for complex expressions, we need to update a grammar to:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>expression :: formula ((AND | OR | IFSO) expression)*
</pre></td></tr></tbody></table>
</div>

<p>This allows for recursive expressions. And, to encode that in our method, we simply replace the <code>formula</code> param passed to the AST operator intializers with a recursive call to <code>expression</code>:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>

  <span class="c1"># expression :: formula ((AND | OR | IFSO) expression)*</span>
  <span class="k">def</span> <span class="nf">expression</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">formula</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:AND</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:AND</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Conjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:OR</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:OR</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Disjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:IFSO</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:IFSO</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Implication</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">result</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>We can add a couple more tests to ensure that our change is doing what we expect:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">run_tests</span>
  <span class="c1"># ...</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'T &amp; F v T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'F &amp; T v T'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~T &amp; F v T'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~F &amp; T v T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<blockquote>
  <p>You can find the script we have built to this point in <a href="https://gist.github.com/fractaledmind/a072674b18086fdebf3b3a535c0f7dfb/e61a5a1b8339119e3e8b75d141282e0b15ac37f1">this revision of this Gist</a></p>
</blockquote>

<hr />

<h3 id="operator-precedence">Operator Precedence</h3>

<p>The final issue we have with our interpreter is that is doesn’t properly handle the precedence of the logical operators. Operator precedence describes the order of operations in an expression. In arithmetic, I remember learning this mnemonic to remember the order of operations: “Please excuse my dear aunt Sally”. This is an acronym mnemonic for “Parentheses exponentiation multiplication division addition substraction”, or, to put it in tabular form:</p>

<table class="tables">
  <thead>
    <tr>
      <th style="text-align: center">Operator</th>
      <th style="text-align: center">Precedence</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code>^</code></td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>*</code></td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>/</code></td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>+</code></td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>-</code></td>
      <td style="text-align: center">3</td>
    </tr>
  </tbody>
</table>

<p>This order of operations says that the arithmetic expression <code>1^2 * 3 / 4 + 5 - 6</code> should be evaluated as <code>((((1^2) * 3) / 4) + 5) - 6</code>. So, operator precedence tells our interpreter what order to evaluate the operations in. Should it evaluate the multiplication before the addition, or vice versa?</p>

<p>In propositional logic, the operator precedence is “negation conjunction disjunction implication”:</p>

<table class="tables">
  <thead>
    <tr>
      <th style="text-align: center">Operator</th>
      <th style="text-align: center">Precedence</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code>~</code></td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>&amp;</code></td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>v</code></td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center"><code>&gt;</code></td>
      <td style="text-align: center">4</td>
    </tr>
  </tbody>
</table>

<p>So, let’s look back at one of the tests we added for handling multiple binary operators:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'F &amp; T v T'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
</pre></td></tr></tbody></table>
</div>

<p>Given the operator precedence, how should <code>F &amp; T v T</code> be understood? Since conjunction (<code>&amp;</code>) has a higher precedence than disjunction (<code>v</code>), it should be read as <code>(F &amp; T) v T</code>, which would evaluate as <code>true</code>; however, we can see that our test expects it to be <code>false</code>. If you have been running the code as we have gone along, step by step, you would have seen your tests pass. This is because our interpreter has no sense of operator precedence and so evaluates the expression from left to right (e.g., in this case, it reads that expression as <code>F &amp; (T v T)</code>).</p>

<p>We need to encode the precedence of our operators, but how do we do so?</p>

<p>I’ll be honest, my first thought was to tweak the order of the branches in the <code>if/else</code> clause of the <code>Parser#expression</code> methods. This will not solve the problem. Regardless of the order of the conditions, if all of those conditions live in the same method, the parser will still imply precedence from left to right. To encode the logic that this operator take precedence over that operator, regardless of which comes first in the expression, we need the precedence levels to be encoded as separate methods; that is, we need to expand our grammar.</p>

<p>This is the state of our grammar after our additions and improvements above:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>expression :: formula ((AND | OR | IFSO) expression)*
formula :: (NOT)* formula | LPAREN expression RPAREN | term
term :: TRUE | FALSE
</pre></td></tr></tbody></table>
</div>

<p>We can recall from <a href="http://fractaledmind.com/articles/ruby-logic-interpreter-1/#the-interpreter">the section on the visitor pattern</a> from the previous post that our abstract syntax tree is <em>evaluated</em> from the lowest (leftmost) nodes up. So, for a tree like this:</p>

<div class="tree">
  <ul>
    <li>
      <a href="#" class="monospace bg-lightgrey font-1em bold">&amp;</a>
      <ul>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">~</a>
          <ul>
            <li>
              <a href="#" class="monospace bg-lightgrey font-1em bold">T</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">F</a>
        </li>
      </ul>
    </li>
  </ul>
</div>

<p>We will visit nodes until we get the bottom, leftmost <code>T</code> node. The interpreter will then negate it (moving up the tree from the <code>T</code> node to its parent), and then evaluate that result as the lefthand side of the conjunction with the <code>F</code> node on the right. I bring this back up because it will help us to encode our operator precedence. Since our AST is evaluated from the bottom up, we want the operators with the highest precendences to be put lower in the tree. We can see that negation is already encoded as having a higher precedence than conjunction, since the expression <code>~T &amp; F</code> put the negation operator node below the conjunction node. But, why?</p>

<p>Well, the short answer is what I was getting at before, at the parser level, precedence is encoded via rule/method layering. Since the negation operator is defined as being a part of the <code>formula</code> rule/method, which is used as a part of the <code>expression</code> rule/method, it will <em>always</em> be placed lower than the binary operators defined as a part of the <code>expression</code> rule/method in the abstract syntax tree that the parser generates. So, if we want to distinguish the operator precedence of the binary operators, we will need to define a distinct rule for each of them, and those rules will need to be ordered to encode the precedence. Let’s start defining these rules simply by taking the <code>expression</code> rule and splitting out the operators into separate rules:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>expression :: formula ((AND | OR | IFSO) expression)*
</pre></td></tr></tbody></table>
</div>

<p>becomes</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>conjunction :: formula (AND expression)*
disjunction :: formula (OR expression)*
implication :: formula (IFSO expression)*
</pre></td></tr></tbody></table>
</div>

<p>Now, how do we encode the operator precedence order? The key is the how the grammar rule definitions “nest”. In the original grammar, <code>expression</code> was the topmost rule, and it called into <code>formula</code>, which in term called into <code>term</code>. And our abstract syntax tree would mirror this nesting; Boolean values were placed beneath the negation operator, which would be placed beneath any binary operators. So, in order to encode the operator precedence of the binary operators, we need to nest the rules properly. Since conjunction has the highest precedence, we want it lowest in the tree, just above negation:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>expression :: conjunction ((OR | IFSO) expression)*
conjunction :: formula (AND expression)*
formula :: (NOT)* formula | LPAREN expression RPAREN | term
term :: TRUE | FALSE
</pre></td></tr></tbody></table>
</div>

<p>Disjunction is next; we want it to end up above conjunctions in the tree, so:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>expression : disjunction (IFSO expression)*
disjunction :: conjunction (OR expression)*
conjunction :: formula (AND expression)*
formula :: (NOT)* formula | LPAREN expression RPAREN | term
term :: TRUE | FALSE
</pre></td></tr></tbody></table>
</div>

<p>And now our <code>expression</code> rule has simply become our <code>implication</code> rule. We now have a grammar where the operators with the lower precedence are higher in the levels of rules. Let’s now encode this grammar in our parser.</p>

<p>The only change we must make is what method we call for the right hand side of an operation. Right now, each operation rule calls <code>expression</code> to evaluate the right hand side. If we leave our grammar as is, we would actually end up with the <em>exact same</em> result as when our grammar only had the <code>expression</code>, <code>formula</code>, and <code>term</code> rules. This is because if we “restart” the evaluation chain at the top (the <code>expression</code> rule/method) for every right hand operand, our parser will end up grouping operations from left to right again. Since the new <code>expression</code>, <code>disjunction</code>, and <code>conjunction</code> rules/methods all check if the current token is their respective operator, if we evaluate the right hand side of any of these operations back at expression, we will <em>always</em> end up running a method that finds the next operator and thus groups the sub-expressions in a simplistic, left-to-right manner.</p>

<p>Maybe an actual example will help explain this point. Let’s return to our earlier example of <code>F &amp; T v T</code>. What will happen when our parsers evaluates the tokens that represent this expression?</p>

<p>First, the <code>expression</code> method is called inside of the <code>parse</code> method</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">parse</span>
  <span class="n">expression</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>The <code>expression</code> method then calls the <code>disjunction</code> method to hydrate its internal <code>result</code> variable</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">expression</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">disjunction</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>The <code>disjunction</code> method then calls the <code>conjunction</code> method to hydrate its internal <code>result</code> variable</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">disjunction</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">conjunction</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>The <code>conjunction</code> method then calls the <code>formula</code> method to hydrate its internal <code>result</code> variable</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">conjunction</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">formula</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>The <code>formula</code> method checks if the current token is a negation operator</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">formula</span>
  <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

  <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:NOT</span>
    <span class="c1"># ...</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>It isn’t (its a true token), so it checks if the current token is a left parens token</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">formula</span>
  <span class="c1"># ...</span>
  <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:LPAREN</span>
    <span class="c1"># ...</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>It isn’t, so it calls the <code>term</code> method</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">formula</span>
  <span class="c1"># ...</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">term</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>The <code>term</code> method checks if the current token is a true token</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">term</span>
  <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

  <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:TRUE</span>
    <span class="c1"># ...</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>It isn’t, so it checks if the current token is a false token</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">term</span>
  <span class="c1"># ...</span>
  <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:FALSE</span>
    <span class="c1"># ...</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>It is, so it moves the current token pointer to the next token in the stream (now the current_token is the <code>&amp;</code> conjunction operator token) and returns the <code>false</code> value to the <code>formula</code> method</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">term</span>
  <span class="c1"># ...</span>
  <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:FALSE</span>
    <span class="n">eat</span><span class="p">(</span><span class="ss">:FALSE</span><span class="p">)</span>
    <span class="k">return</span> <span class="no">AST</span><span class="o">::</span><span class="no">Atom</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>The <code>formula</code> method then immediately returns that value to the <code>conjunction</code> method</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">formula</span>
  <span class="c1"># ...</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">term</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>The <code>conjunction</code> method therefore sets the internal <code>result</code> variable of the <code>conjunction</code> method to the <code>false</code> value</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">conjunction</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">formula</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>And then it checks if the new current token is the conjunction operator token</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">conjunction</span>
  <span class="c1"># ...</span>
  <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

  <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:AND</span>
    <span class="c1"># ...</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>It is, so it moves the current token point to the next token in the stream (now the current token is the <code>T</code> true token) and updates its internal <code>result</code> variable to a conjunction node where the left hand operand is the previous <code>result</code> value (aka the <code>false</code> value) and the right hand operand is a call to <code>expression</code></p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">conjunction</span>
  <span class="c1"># ...</span>
  <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:AND</span>
    <span class="n">eat</span><span class="p">(</span><span class="ss">:AND</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Conjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>So we have now called the <code>expression</code> method and the current token is now pointing to the the <code>T</code> token. The parser will make its way through the various methods until it gets back to the <code>term</code> method, which will return the <code>true</code> value node and move the current token pointer to the <code>v</code> disjunction operator token. In the process of finishing the evaluation of this second call to <code>expression</code> (the call originating from the <code>conjunction</code> method), the <code>disjunction</code> method will be called and it will check if the current token is the disjunction operator. And since it is, it will create a new disjunction node and call <code>expression</code> itself with the new current token set to the final <code>T</code> token. This third call to <code>expression</code> (originating from the <code>disjunction</code> method) will return the <code>true</code> value node so that the right hand side of the disjunction node is that <code>true</code> value. And then the result of that call to <code>disjunction</code> will be returned all the way up to the second call to <code>expression</code>. The right hand side of the conjunction node will therefore be this disjunction node, and with that our parser will finish. It will output an conjunction node where the left hand side is a false value and the right hand side is a disjunction. This is the exact same (faulty) result that our parser had at the end of the last post.</p>

<p>If we call <code>expression</code> to evaluate the right hand side of our binary operations, our parser will end up continuing to parse the order of operations simply based on left-to-right appearance order. In order to ensure the actual order of operations, we need a way to “cap” how high back up the hierarchy methods our parser can go. To put it another way, we want to ensure that if our parser finds a conjunction as the first operation it hits, it guarantees that the right hand side of that conjunction can <em>only</em> be either a Boolean value or a negation operation (since negation has a higher precedence than conjunction); the right hand side of a conjunction <em>cannot</em> be a disjunction (unless of course we use parentheses to explicitly group our expression that way, but we have already solved that problem). In order to achieve this result, we simply need to change the methods that are called for the right hand side of a binary operation to be calls <em>back to that same method</em>. Since our method calls are nested, this will allow the right hand side to be evaluated as any operation or value that has either the same precedence as lower.</p>

<p>I know that this was a pretty large “detour”, but it took me a while to feel like I fully understood <strong>why</strong> our grammar (and thus our parser) <em>needed</em> to have this shape to properly encode our operator precedence. So, our final grammar is:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>expression : disjunction (IFSO expression)*
disjunction :: conjunction (OR disjunction)*
conjunction :: formula (AND conjunction)*
formula :: (NOT)* formula | LPAREN expression RPAREN | term
term :: TRUE | FALSE
</pre></td></tr></tbody></table>
</div>

<p>And our final parse rule methods are:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>

  <span class="c1"># expression :: disjunction (IFSO expression)*</span>
  <span class="k">def</span> <span class="nf">expression</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">disjunction</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:IFSO</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:IFSO</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Implication</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">result</span>
  <span class="k">end</span>

  <span class="c1"># disjunction :: conjunction (OR disjunction)* </span>
  <span class="k">def</span> <span class="nf">disjunction</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">conjunction</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:OR</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:OR</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Disjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">disjunction</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">result</span>
  <span class="k">end</span>

  <span class="c1"># conjunction :: formula (AND conjunction)* </span>
  <span class="k">def</span> <span class="nf">conjunction</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">formula</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:AND</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:AND</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Conjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">conjunction</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">result</span>
  <span class="k">end</span>

  <span class="c1"># formula :: (NOT)* formula | LPAREN expression RPAREN | term</span>
  <span class="c1"># remains the same</span>

  <span class="c1"># term :: TRUE | FALSE</span>
  <span class="c1"># remains the same</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>We can now update our non-grouped binary expression tests:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">run_tests</span>
  <span class="c1"># ...</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'F &amp; T v T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_interpret_equals</span><span class="p">(</span><span class="s1">'~F &amp; T v T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<hr />

<h3 id="wrapping-up">Wrapping Up</h3>

<p>We have now successfully implemented an interpreter that handles the full suite of valid expressions in classical propositional logic:</p>

<ul>
  <li>it handles stacked negation operators (e.g. <code>~~T</code>),</li>
  <li>it handles parentheses to group sub-expressions (e.g. <code>~(T v F) &amp; T</code>),</li>
  <li>it handles multiple binary operators used in one expression (e.g. <code>T &amp; F v T</code>), and</li>
  <li>it handles the proper operator precedence of the logical operators</li>
</ul>

<p>Some of these bits of functionality were easier to implement than others, but we learned a lot more about our parser and the grammar needed to describe a language with the added complexity of robust classical logic.</p>

<p>In the next post, I want us to expand our interpreter to allow for variables in our expressions, like <code>P &amp; Q</code>. That should be fun.</p>

<blockquote>
  <p>You can find the script we have built to this point in <a href="https://gist.github.com/fractaledmind/a072674b18086fdebf3b3a535c0f7dfb/0c340cfc3437522d0ec45bd3f7b7820133d25fbd">this revision of this Gist</a></p>
</blockquote>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>I say “classical propositional logic” because modern propositional logic has many more valid operators. But this is an addition we will get to in the next post. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>
</div>

    </div>

    <aside id="sidebar">

  <hr class="fractal">

  <div id="recent-articles">
    <h5>Recent Posts</h5>
    <ul class="fa-ul">
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../slideover-bootstrap-modals/">Slideover Bootstrap Modals</a>
        </li>
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../rails-forms-and-request-parameters/">Rails Forms and Request Parameters</a>
        </li>
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../expecting-exceptions-in-ruby/">Expecting Exceptions in Ruby</a>
        </li>
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../safely-accessing-values-from-a-nested-hash-again/">Safely Accessing Values from Nested Hashes (again)'</a>
        </li>
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../basic-restful-filtering-with-rails/">Basic RESTful Filtering with Rails</a>
        </li>
    </ul>
  </div>

  <hr class="fractal">

  <div id="all-tags">
    <h5><a href="../../topics/">Topics</a></h5>
    <ul class="list-none">
      <!-- Add all Article tags -->
        <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="epistemology-tag" href="/topics/epistemology/">epistemology</a>
            <a class="math-tag" href="/topics/math/">math</a>
        </li>
        <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="epistemology-tag" href="/topics/epistemology/">epistemology</a>
            <a class="logic-tag" href="/topics/logic/">logic</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="pdf-workflow-tag" href="/topics/pdf-workflow/">pdf-workflow</a>
        </li>
        <li class="breadcrumb">
            <a class="prose-tag" href="/topics/prose/">prose</a>
            <a class="self-tag" href="/topics/self/">self</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="ruby-tag" href="/topics/ruby/">ruby</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="rails-tag" href="/topics/rails/">rails</a>
        </li>
        <li class="breadcrumb">
            <a class="poetry-tag" href="/topics/poetry/">poetry</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="algorithms-tag" href="/topics/algorithms/">algorithms</a>
        </li>
        <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="faith-tag" href="/topics/faith/">faith</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="git-tag" href="/topics/git/">git</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="git-tag" href="/topics/git/">git</a>
        </li>
        <li class="breadcrumb">
            <a class="prose-tag" href="/topics/prose/">prose</a>
            <a class="relationships-tag" href="/topics/relationships/">relationships</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="css-tag" href="/topics/css/">css</a>
            <a class="trees-tag" href="/topics/trees/">trees</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="css-tag" href="/topics/css/">css</a>
            <a class="trees-tag" href="/topics/trees/">trees</a>
        </li>
        <li class="breadcrumb">
            <a class="poetry-tag" href="/topics/poetry/">poetry</a>
            <a class="relationships-tag" href="/topics/relationships/">relationships</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="css-tag" href="/topics/css/">css</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="http-tag" href="/topics/http/">http</a>
        </li>
        <li class="breadcrumb">
            <a class="prose-tag" href="/topics/prose/">prose</a>
            <a class="life-tag" href="/topics/life/">life</a>
        </li>
        <li class="breadcrumb">
            <a class="prose-tag" href="/topics/prose/">prose</a>
            <a class="faith-tag" href="/topics/faith/">faith</a>
        </li>
        <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="ethics-tag" href="/topics/ethics/">ethics</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="ruby-tag" href="/topics/ruby/">ruby</a>
            <a class="interpreter-tag" href="/topics/interpreter/">interpreter</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="interpreter-tag" href="/topics/interpreter/">interpreter</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="css-tag" href="/topics/css/">css</a>
            <a class="bootstrap-tag" href="/topics/bootstrap/">bootstrap</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="mvc-tag" href="/topics/mvc/">mvc</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="latin-tag" href="/topics/latin/">latin</a>
            <a class="vergil-tag" href="/topics/vergil/">vergil</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="epicurus-tag" href="/topics/epicurus/">epicurus</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="aristotle-tag" href="/topics/aristotle/">aristotle</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="latin-tag" href="/topics/latin/">latin</a>
            <a class="horace-tag" href="/topics/horace/">horace</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="modern-tag" href="/topics/modern/">modern</a>
            <a class="lewis-tag" href="/topics/lewis/">lewis</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="modern-tag" href="/topics/modern/">modern</a>
            <a class="barfield-tag" href="/topics/barfield/">barfield</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="herodotus-tag" href="/topics/herodotus/">herodotus</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="hippocrates-tag" href="/topics/hippocrates/">hippocrates</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="plato-tag" href="/topics/plato/">plato</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="modern-tag" href="/topics/modern/">modern</a>
            <a class="saussure-tag" href="/topics/saussure/">saussure</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="alfred-tag" href="/topics/alfred/">alfred</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="bash-tag" href="/topics/bash/">bash</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="python-tag" href="/topics/python/">python</a>
        </li>
    </ul>
  </div>
</aside>


    <footer role="contentinfo">
  <div class="footer-info">
    <p>&copy; Copyright 2015 by Stephen Margheim</p>
    <p>Powered by <a href="https://middlemanapp.com">Middleman</a>.</p>
  </div>
</footer>


  </body>
</html>
