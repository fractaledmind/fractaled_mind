<!doctype html>
<html lang="en">
  <head>
  <!-- Metadata declarations -->
  <meta charset="utf-8" />
  <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Content declarations -->
  <title>Fractaled Mind</title>
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="feed.xml" />

  <!-- External Resources -->
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js" ></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  <!-- Internal Resources -->
  <link href="../../stylesheets/main.css" rel="stylesheet" type="text/css" />
  <link href="../../images/favicon.png" rel="icon" type="image/png" />
  <script src="../../javascripts/bigfoot.js" type="text/javascript"></script>
  <script src="../../javascripts/search.js" type="text/javascript"></script>

  <!-- Bigfoot.js Popover Footnotes -->
  <script type="text/javascript">
    $(document).ready(function(){
      $.bigfoot({
        numberResetSelector: ".card",
        activateCallback: function($popover, $button) {
          if (MathJax && !$button.data('mathjax-processed')) {
            var content_wrapper = $popover.find('.bigfoot-footnote__content')[0];
            MathJax.Hub.Queue(['Typeset', MathJax.Hub, content_wrapper]);
            MathJax.Hub.Queue(function () {
              $button.attr('data-bigfoot-footnote', content_wrapper.innerHTML);
              $button.data('mathjax-processed', true);
            });
          }
        }
      });
    });
  </script>

  <!-- Responsive Tables -->
  <script type="text/javascript">
    $(document).ready(function(){
      $("td").each(function() {
        var $th = $(this).closest('table').find('th').eq($(this).index());
        $(this).attr('data-th', $th.text());
      });
    });
  </script>

  <!-- Scroll-Fix sidebar
  <script type="text/javascript">
    $(window).on("scroll", function(e) {
      var scroll = $(this).scrollTop();
      var logo_height = $('#site-logo').height();
      var nav_height = $('.navigation').height() + 16;

      if (scroll > logo_height) {
        $('.navigation').css({'position': 'fixed'});
         $('#sidebar').css({
           'position': 'fixed',
           'top': nav_height
         });
      } else {
        $('.navigation').css({'position': 'inherit'});
        $('#sidebar').css({'position': 'inherit'});
      }
    });
  </script>
  -->

</head>


  <body>
    <header>
  <div id="site-logo">
    <a href="/" class="no-hvr">
      <img alt="Fractaled Mind" src="../../images/logo-single-line.svg" />
    </a>
  </div>
</header>


    <div class="navigation">
  <ul id="social-networks">
    <li>
      <a href="https://facebook.com/fractaledmind" class="no-hvr">
        <i class="fa fa-facebook fa-lg"></i>
      </a>
    </li>
    <li>
      <a href="https://twitter.com/fractaledmind" class="no-hvr">
        <i class="fa fa-twitter fa-lg"></i>
      </a>
    </li>
    <li>
      <a href="https://github.com/fractaledmind" class="no-hvr">
        <i class="fa fa-github fa-lg"></i>
      </a>
    </li>
    <li>
      <a href="mailto:stephen@fractaledmind.com" class="no-hvr">
        <i class="fa fa-envelope fa-lg"></i>
      </a>
    </li>
    <li>
      <a href="/feed.xml" class="no-hvr">
        <i class="fa fa-rss fa-lg"></i>
      </a>
    </li>
  </ul>

  <nav role="navigation">
    <ul class="navigation-menu">
      <li class="nav-link"><a href="../">articles</a></li>
      <li class="nav-link"><a href="../../projects/">projects</a></li>
      <li class="nav-link"><a href="../../jots/">jots</a></li>
      <li class="nav-link"><a href="../../essays/">essays</a></li>
    </ul>
  </nav>

  <div id="search">
    <div class="searchbar">
      <form role="search" action="/search" method="get">
        <input class="search-term" type="search" placeholder="Search..." name="q" />
        <button class="search-submit" type="submit">
          <img src="https://raw.githubusercontent.com/thoughtbot/refills/master/source/images/search-icon-black.png" alt="Search Icon">
        </button>
      </form>
    </div>
  </div>
</div>


    <div id="main" role="main">
      <div class="card" id="project-page">

    <ul class="card-tags">
      <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="ruby-tag" href="/topics/ruby/">ruby</a>
            <a class="interpreter-tag" href="/topics/interpreter/">interpreter</a>
      </li>
      <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="epistemology-tag" href="/topics/epistemology/">epistemology</a>
            <a class="logic-tag" href="/topics/logic/">logic</a>
      </li>
      <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="interpreter-tag" href="/topics/interpreter/">interpreter</a>
      </li>
  </ul>


  <!-- if item has tags, add filler element -->
  <div id="tag-filler-space"></div>


  

  <h2 id="title"><p>Building an Interpreter for Propositional Logic</p>
</h2>

  <hr class="fractal">

  <div id="description"><p>I recently got the itch to dig into how compilers/interpreters worked and were built. So, I’ve decided to start a new series here on the site to follow my exploration of building an interpreter (in Ruby).</p>

<p>I didn’t want to start by defining my own language to interpret, and I have always loved and been fascinated by logic, so I thought I would build an interpreter for working with logical expressions.</p>

<hr />

<h3 id="the-language-of-logic">The Language of Logic</h3>

<p>Let’s start small and simple, so for this first post we are only going to build an interpreter for handling the most common operations in <a href="http://www.iep.utm.edu/prop-log/">propositional logic</a>:<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></p>

<table class="tables">
  <thead>
    <tr>
      <th style="text-align: left">Name</th>
      <th style="text-align: center">Symbol</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Conjunction</td>
      <td style="text-align: center"><code>&amp;</code></td>
    </tr>
    <tr>
      <td style="text-align: left">Disjunction</td>
      <td style="text-align: center"><code>v</code></td>
    </tr>
    <tr>
      <td style="text-align: left">Implication</td>
      <td style="text-align: center"><code>&gt;</code></td>
    </tr>
    <tr>
      <td style="text-align: left">Negation</td>
      <td style="text-align: center"><code>~</code></td>
    </tr>
  </tbody>
</table>

<p>In addition to these operators, a logical expression must also have some sort of <em>operand</em>. Propositional logic is the simplest form of logic and only has two kinds of operands: <code>True</code> and <code>False</code>, which we will represent in our language as <code>T</code> and <code>F</code>.</p>

<p>So, in total, our language is composed of only 6 tokens:</p>

<div style="display:flex;justify-content:space-around;margin-bottom:1rem;">
  <code>T</code>
  <code>F</code>
  <code>~</code>
  <code>&amp;</code>
  <code>v</code>
  <code>&gt;</code>
</div>

<p>Simple.</p>

<p>The next thing we need to consider is how these tokens are used to form a valid expression. First and foremost, the simplest possible valid expression is simply an operand; so, <code>T</code> and <code>F</code> are both valid expressions in our language. Of our 4 operators, only the negation operator is a so-called <em>unary</em> operator, which simply means that it is an operator that works on only <em>1</em> operand. In our language, unary operators must come before their operand, so <code>~T</code> and <code>~F</code> are both valid expressions, but <code>T~</code> or <code>F~</code> or <code>~&amp;</code> are not valid expressions. Finally, our other tokens are all <em>binary</em> operators, which means they work on only <em>2</em> operands. Our language will use the so-called <em>infix notation</em> for binary operators, which means that the operator <em>comes between</em> the two operands; so, <code>T &amp; T</code>, <code>T v F</code>, and <code>T &gt; T</code> are all valid expressions.</p>

<p>Now that we have a clear sense of what our language for this subset of propositional logic will look like, the final thing we need to clarify before turning to building the actual interpreter is how our valid expressions are supposed to be evaluated. We have thought through the shape and nature of the input of our interpreter, but we also have to think through the output. When we interpret an expression like <code>T &amp; F</code>, what should the output be? Propositional logic, as noted above, only works with two types of values, <code>True</code> and <code>False</code> (i.e. the <a href="https://en.wikipedia.org/wiki/Boolean_data_type">Boolean values</a>). So, when considering how our operators should be evaluated, we simply need to know how each operator responds to the various permutations of the possible values. The unary negation operator is the simplest, so let’s start there.</p>

<div style="display:flex;justify-content:space-around;margin-bottom:1rem;">
  <table class="truth-table">
    <thead>
      <tr>
        <th><code>~</code></th>
        <th></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th>T</th>
        <td>F</td>
      </tr>
      <tr>
        <th>F</th>
        <td>T</td>
      </tr>
    </tbody>
  </table>
</div>

<p>This is a <a href="https://en.wikipedia.org/wiki/Truth_table"><em>truth table</em></a> and it represents how the negation operator (<code>~</code>) is evaluated for the two possible values it can operate on.</p>

<p>For the binary operators, there are four possible states:</p>

<div style="display:flex;justify-content:space-around;margin-bottom:1rem;">
  <table class="truth-table">
    <thead>
      <tr>
        <th><code>&amp;</code></th>
        <th>T</th>
        <th>F</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th>T</th>
        <td>T</td>
        <td>F</td>
      </tr>
      <tr>
        <th>F</th>
        <td>F</td>
        <td>F</td>
      </tr>
    </tbody>
  </table>

  <table class="truth-table">
    <thead>
      <tr>
        <th><code>v</code></th>
        <th>T</th>
        <th>F</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th>T</th>
        <td>T</td>
        <td>T</td>
      </tr>
      <tr>
        <th>F</th>
        <td>T</td>
        <td>F</td>
      </tr>
    </tbody>
  </table>

  <table class="truth-table">
    <thead>
      <tr>
        <th><code>&gt;</code></th>
        <th>T</th>
        <th>F</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th>T</th>
        <td>T</td>
        <td>F</td>
      </tr>
      <tr>
        <th>F</th>
        <td>T</td>
        <td>T</td>
      </tr>
    </tbody>
  </table>
</div>

<p>These are the rules that our interpreter is going to have to encode when it comes time to actually evaluate the expressions. For our initial pass we aren’t going to worry yet about the <a href="https://en.wikipedia.org/wiki/Order_of_operations">order of precedence</a> of the operators as we will only be working with simple expressions (e.g. expressions with only one binary operator). So, having laid out the shape of the input our interpreter is going to be working with as well as the output it needs to generate, let’s go ahead and write some simple tests that can help guide as we start working on the actual Ruby code:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></td><td class="code"><pre><span class="c1"># the classes and methods reference are what we will eventually build</span>
<span class="k">def</span> <span class="nf">assert_expression_equals</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
  <span class="n">error_msg</span> <span class="o">=</span> <span class="s2">"Expected '</span><span class="si">#{</span><span class="n">expression</span><span class="si">}</span><span class="s2">' to evaluate to </span><span class="si">#{</span><span class="n">result</span><span class="si">}</span><span class="s2">"</span>

  <span class="n">tokens</span> <span class="o">=</span> <span class="no">Lexer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">expression</span><span class="p">).</span><span class="nf">tokens</span>
  <span class="n">ast</span> <span class="o">=</span> <span class="no">Parser</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">tokens</span><span class="p">).</span><span class="nf">parse</span>
  <span class="n">result</span> <span class="o">=</span> <span class="no">Interpreter</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">ast</span><span class="p">).</span><span class="nf">interpret</span>

  <span class="k">raise</span> <span class="n">error_msg</span> <span class="k">unless</span> <span class="n">interpret</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span> <span class="o">==</span> <span class="n">result</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">run_tests</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'F'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>

  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'~T'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'~F'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>

  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'T &amp; T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'T &amp; F'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'F &amp; T'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'F &amp; F'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>

  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'T v T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'T v F'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'F v T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'F v F'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>

  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'T &gt; T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'T &gt; F'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'F &gt; T'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'F &gt; F'</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>

  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'~F &amp; F'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="n">assert_expression_equals</span><span class="p">(</span><span class="s1">'F v ~T'</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>

  <span class="s1">'SUCCESS!'</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<hr />

<h3 id="the-basics-of-interpreters">The Basics of Interpreters</h3>

<p>When starting on this quest, I began by doing what I typically do at the outset of some new task: I Googled and I read. The resource I found most helpful was a <a href="https://ruslanspivak.com/lsbasi-part1/">series of posts</a> by <a href="https://ruslanspivak.com/pages/about/">Ruslan Spivak</a>. There he ends up building an interpreter for the Pascal language, but starts with a simpler calculator. Our goal is much more similar to a calculator than a full programming language, so we can use his early posts as our baseline.</p>

<p>Over the course of his posts on building the calculator, Ruslan lays out that interpreting is typically decomposed into 3 separate stages:</p>

<div style="display:flex;justify-content:space-around;align-items:center;margin-bottom:1rem;">
  <span style="border:thin solid;padding:0.25em 0.5em;padding-top:0.33em;border-radius:4px">
    lexical analysis
  </span>
  <span>&rarr;</span>
  <span style="border:thin solid;padding:0.25em 0.5em;padding-top:0.33em;border-radius:4px">
    parsing
  </span>
  <span>&rarr;</span>
  <span style="border:thin solid;padding:0.25em 0.5em;padding-top:0.33em;border-radius:4px">
    interpreting
  </span>
</div>

<p><em>Lexical analysis</em> is the process of breaking the input string into tokens (we’ll get to what tokens are in just a bit). The tool that does the lexical analysis is called a <em>lexer</em>, and it is the tool that is going to need to know about the set of tokens for our language that we laid out above. <em>Parsing</em>, then, is the process of finding structure in the stream of tokens, and the tool that does the parsing is – you guessed it – called a <em>parser</em>. The parser is what will need to know about what constitutes a valid expression, as outlined above. Finally, <em>interpreting</em> takes the structured output of the parser and evaluates it to get a result (in our case, some Boolean value). So, we are going to need 3 basic classes:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Lexer</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Parser</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Interpreter</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<hr />

<h3 id="the-lexer">The Lexer</h3>

<p>Our lexer is going to take a string representation of a logical expression and convert it into a collection of tokens. Okay, well, what are tokens? Tokens are the basic, abstract units of the language that the interpreter will, well, interpret. To understand what a token is, it may be easiest to jump over to Ruslan’s example of a calculator. <code>2 + 2</code> and <code>5 - 3</code> are both valid arithmetic expressions. Disregarding whitespace, each expression is composed of 3 characters: <code>['2', '+', '2']</code> and <code>['5', '-', '3']</code>. We, as people who understand basic arithmetic, know that there are two different categories of characters in these lists—integers and operators. <code>['2', '5', '3']</code> are all examples of integers, and <code>['+', '-']</code> are both operators. To put this in the language of interpreters and lexers, we would say that, for example, <code>2</code> is a token of the integer type with a value of “2”, while <code>+</code> is a token of the addition type with a value of “+”. Now, I just said that <code>+</code> is a token of the addition type, not the operator type; why? If our interpreter needs to do different things depending on the exact operator, each operator needs a distinct type. While <code>+</code> and <code>-</code> are both operators, they are different operators that do different things.</p>

<p>This brings us to the final bit of jargon for this section: <em>lexemes</em>. If tokens are the abstract units of the language (e.g. integers, addition operators, subtraction operators), lexemes are the concrete values of some particular token. So, <code>2</code> and <code>5</code> are both integer tokens, but each has a different lexeme; or, to put it otherwise, the integer token type can have a variety of lexemes (e.g. <code>2, 5, 3, 11, 100,</code> etc.). The addition token, however, in the basic implementation of a calculator, will only ever have one lexeme—<code>+</code>.</p>

<p>Well, what does all of this mean for the code we need to write? It means that we will need a <code>Token</code> class that has <code>#type</code> and <code>#value</code> attributes:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Token</span>
  <span class="kp">attr_reader</span> <span class="ss">:type</span><span class="p">,</span> <span class="ss">:value</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="vi">@type</span> <span class="o">=</span> <span class="n">type</span>
    <span class="vi">@value</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>The next thing we need to do is define the set of possible token types for our language. I’m going to base the names of the types on the constants used for <a href="https://en.wikipedia.org/wiki/Logic_gate#Symbols">logical gates</a>; so, the set of possible operator types will be: <code>[:AND, :OR, :IFSO, :NOT]</code>.<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> Given the simplicity of our language here at the outset:</p>

<ul>
  <li>every <code>Token</code> of type <code>:AND</code> will have a value of <code>&amp;</code>;</li>
  <li>every <code>Token</code> of type <code>:OR</code> will have a value of <code>v</code>;</li>
  <li>every <code>Token</code> of type <code>:IFSO</code> will have a value of <code>&gt;</code>;</li>
  <li>every <code>Token</code> of type <code>:NOT</code> will have a value of <code>~</code>;</li>
</ul>

<p>The only other types of <code>Token</code> we need for this basic implementation of our logic interpreter are Boolean type. We will define a <code>:TRUE</code> type and <code>:FALSE</code> type. Again, we are keeping things simple here at the outset, so these types will likewise only have one possible value:</p>

<ul>
  <li>every <code>Token</code> of type <code>:TRUE</code> will have a value of <code>T</code>;</li>
  <li>every <code>Token</code> of type <code>:FALSE</code> will have a value of <code>F</code>;</li>
</ul>

<p>Our lexer thus needs to convert the string representation of the logical expression into a collection of tokens of these types:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Lexer</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
    <span class="vi">@input</span> <span class="o">=</span> <span class="n">input</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">tokens</span>
    <span class="c1"># returns an array of Token instances</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>We are essentially converting one kind of stream (a string) into another (a stream of <code>Token</code>s), so let’s use <code>Enumerable#map</code> as the heart of our <code>tokens</code> method:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Lexer</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">tokens</span>
    <span class="vi">@input</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">''</span><span class="p">).</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">char</span><span class="o">|</span>
      <span class="c1"># for each `char`, there are only 6 possible things to do</span>
      <span class="k">case</span> <span class="n">char</span>
      <span class="k">when</span> <span class="s1">' '</span>
        <span class="k">next</span>
      <span class="k">when</span> <span class="s1">'~'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:NOT</span><span class="p">,</span> <span class="n">char</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'&amp;'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:AND</span><span class="p">,</span> <span class="n">char</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'v'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:OR</span><span class="p">,</span> <span class="n">char</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'&gt;'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:IFSO</span><span class="p">,</span> <span class="n">char</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'T'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:TRUE</span><span class="p">,</span> <span class="n">char</span><span class="p">)</span>
      <span class="k">when</span> <span class="s1">'F'</span>
        <span class="no">Token</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:FALSE</span><span class="p">,</span> <span class="n">char</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">compact</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>This method converts our input string into an enumerable array (<code>@input.split('')</code>) and then <code>#map</code>s over that array to create a new array of <code>Token</code> instances. However, since our text input string can contain whitespace, and those are not significant tokens, we skip whitespace (thus inserting <code>nil</code>s into our output array) and then remove the <code>nil</code>s with the call to <code>#compact</code> at the end.</p>

<p>This method will hande a wide variety of expressions:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre>$&gt;Lexer.new('~T').tokens
=&gt; [#&lt;NOT value="~"&gt;, #&lt;TRUE value="T"&gt;]

$&gt;Lexer.new('F &amp; T').tokens
=&gt; [#&lt;FALSE value="F"&gt;, #&lt;AND value="&amp;"&gt;, #&lt;TRUE value="T"&gt;]

$&gt;Lexer.new('T v F').tokens
=&gt; [#&lt;TRUE value="T"&gt;, #&lt;OR value="v"&gt;, #&lt;FALSE value="F"&gt;]

$&gt;Lexer.new('T &gt; F').tokens
=&gt; [#&lt;TRUE value="T"&gt;, #&lt;IFSO value="&gt;"&gt;, #&lt;FALSE value="F"&gt;]
</pre></td></tr></tbody></table>
</div>

<hr />

<h3 id="the-parser">The Parser</h3>

<p>With a <code>Lexer</code> built that will output an enumerable of <code>Token</code>s, we can now build a simple <code>Parser</code> that will encode the syntax of our basic propositional logic. But first, what is our parser going to output? Here is where we hit our next big patch of jargon and theory, so let’s go ahead and jump in!</p>

<p>In short, our parser is going to encode a <em>grammar</em> and output an <em>abstract syntax tree</em>; these are the two main bits of jargon we need to make sense of before turning to actually writing our parser. Ruslan has a <a href="https://ruslanspivak.com/lsbasi-part4/">very good introduction to grammars</a> in his series on building an interpreter, but let’s try to get there on our own. A grammar, in this context, is simply a structured representation of what constitutes a valid expression in the language, which is precisely the task we set ourselves to earlier. Any grammar is made up of a series of <em>rules</em>; each <em>rule</em> has a name (called a “start symbol” or the “head” of the rule) and a definition (called the “body” of the rule). The definition of the <em>rule</em> (the <em>body</em>) can refer to other rules or to tokens. But that’s basically it. Let’s go back to Ruslan’s example of a simple calculator to look at a simple grammar for handling addition and subtraction:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>expression :: term ((PLUS | MINUS) term)*
term :: INTEGER
</pre></td></tr></tbody></table>
</div>

<p>This is a grammar defining the structure of a language composed of only 3 types of tokens (<code>PLUS</code>, <code>MINUS</code>, and <code>INTEGER</code>). The simplest rule is the rule for a “term”; a term, in this language, is only ever some particular integer. Somewhat more complicated is the rule for an “expression”; an expression, in this language, is <em>always</em> made up of at least one “term”, but it can optionally (that’s what the <code>(...)*</code> represents) be made up of a term followed by either the plus or minus operator (<code>(PLUS | MINUS)</code>) and then another term. So, this grammar dictates that <code>2</code> is a valid expression, <code>2 + 2</code> is a valid expression, and <code>2 + 2 - 3</code> is also a valid expression.</p>

<p>Now, this is basically as simple as a grammar can be, but that’s ok. We are starting off simple, and this grammar still captures the primary elements and characteristics of the concept.</p>

<p>For our minimal propositional logic language, we are going to need to define the grammar and then encode that logic in our parser. But, before we get quite there, let’s talk a bit about what our parser is going to output—an Abstract Syntax Tree (AST).</p>

<p>An <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> is a very important concept in the world of software development. Whether you know it or not, code you have written has very likely used an abstract syntax tree at some point in its execution (even if only at the low level of compiling your code into machine code). First and foremost, an abstract syntax tree is a <em>tree</em>. This is a particular and oft-used data structure in programming. The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction">DOM</a> is a tree; <a href="http://ruby-doc.org/core-2.4.0/Hash.html">hashes</a> are trees; but what, exactly, is a tree? Simply, a tree is a data structure that consists of one or more nodes organized into a hierarchy. An abstract syntax tree is simply a tree where the nodes represent either the operations or the operands that comprise the language for your interpreter. Ruslan puts it this way:</p>

<blockquote>
  <p>So, what is an abstract syntax tree? An abstract syntax tree (AST) is a tree that represents the abstract syntactic structure of a language construct where each interior node and the root node represents an operator, and the children of the node represent the operands of that operator.</p>
</blockquote>

<p>Jargony? Yes. But also detailed and specific. But, maybe a concrete example will help firm things up. Returning to our simple calculator, what would the abstract syntax tree for the expression <code>2 + 2 - 3</code> look like?</p>

<div class="tree">
  <ul>
    <li>
      <a href="#" class="monospace bg-lightgrey font-1em bold">-</a>
      <ul>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">+</a>
          <ul>
            <li>
              <a href="#" class="monospace bg-lightgrey font-1em bold">2</a>
            </li>
            <li>
              <a href="#" class="monospace bg-lightgrey font-1em bold">2</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">3</a>
        </li>
      </ul>
    </li>
  </ul>
</div>

<p>In the case of our propositional logic language, the abstract syntax tree for the expression <code>~T &amp; F</code> would look like:</p>

<div class="tree">
  <ul>
    <li>
      <a href="#" class="monospace bg-lightgrey font-1em bold">&amp;</a>
      <ul>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">~</a>
          <ul>
            <li>
              <a href="#" class="monospace bg-lightgrey font-1em bold">T</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">F</a>
        </li>
      </ul>
    </li>
  </ul>
</div>

<p>The output of our parser needs simply to encode such a structure. How might we go about that?</p>

<p>Well, the first thing we will need is a class to represent an atom node:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">AST</span>
  <span class="k">class</span> <span class="nc">Atom</span>
    <span class="kp">attr_reader</span> <span class="ss">:value</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
      <span class="vi">@value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>An atom node is the simplest kind of node; you simply initialize it with a value.</p>

<p>Next, we need to encode unary operations (like negation):</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">AST</span>
  <span class="c1"># ...</span>
  <span class="k">class</span> <span class="nc">UnaryOperation</span>
    <span class="kp">attr_reader</span> <span class="ss">:operand</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
      <span class="vi">@operand</span> <span class="o">=</span> <span class="n">operand</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Unary operations, as we recall from above, take only one operand; so, we initialize this kind of AST node with one operand. We only have one unary operation in our language, so let’s define our negation operation node now:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">AST</span>
  <span class="c1"># ...</span>
  <span class="k">class</span> <span class="nc">Negation</span> <span class="o">&lt;</span> <span class="no">UnaryOperation</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Binary operations are quite similar; they simply take two operands instead of one:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">AST</span>
  <span class="c1"># ...</span>
  <span class="k">class</span> <span class="nc">BinaryOperation</span>
    <span class="kp">attr_reader</span> <span class="ss">:left</span><span class="p">,</span> <span class="ss">:right</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
      <span class="vi">@left</span> <span class="o">=</span> <span class="n">left</span>
      <span class="vi">@right</span> <span class="o">=</span> <span class="n">right</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Let’s now define the AST nodes to represent our 3 binary operators:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">AST</span>
  <span class="c1"># ...</span>
  <span class="k">class</span> <span class="nc">Conjunction</span> <span class="o">&lt;</span> <span class="no">BinaryOperation</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Disjunction</span> <span class="o">&lt;</span> <span class="no">BinaryOperation</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Implication</span> <span class="o">&lt;</span> <span class="no">BinaryOperation</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>These classes encode all of the possible nodes for our abstract syntax tree. And, each of these classes is composable with any of the others; that is, like the graphical tree representation, they can be nested such that a negation operation is the left operand of a conjunction operation. All we need now is to build a parser that can accept a stream of tokens and output an abstract syntax tree represented by some composition of our newly minted node classes:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
    <span class="vi">@tokens</span> <span class="o">=</span> <span class="n">tokens</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">parse</span>
    <span class="c1"># this will be the public interface of this class</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Now, before we can write the code that will live in our <code>Parser</code> class, we need to define the grammar for our basic implementation of propositional logic. Let’s start with the grammar for basic arithmetic from above:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>expression :: term ((PLUS | MINUS) term)*
term :: INTEGER
</pre></td></tr></tbody></table>
</div>

<p>First, let’s simply replace the arithmetic binary operations with our binary operations:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>expression :: term ((AND | OR | IFSO) term)*
term :: INTEGER
</pre></td></tr></tbody></table>
</div>

<p>Next, let’s replace the one integer token with our two Boolean tokens:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>expression :: term ((AND | OR | IFSO) term)*
term :: TRUE | FALSE
</pre></td></tr></tbody></table>
</div>

<p>We are nearly there; we just need to handle our unary operation. Let’s add one further rule between the <code>expression</code> rule and the <code>term</code> rule for our negation operation:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>expression :: formula ((AND | OR | IFSO) formula)*
formula :: (NOT)? term
term :: TRUE | FALSE
</pre></td></tr></tbody></table>
</div>

<p>Finally, we are going to change the <code>*</code> in the <code>expression</code> rule to an <code>?</code>. This means that an <code>expression</code> is made up of at least a <code>formula</code> and then either zero or one phrases of the shape operator and formula. The <code>*</code> meant that the <code>formula</code> could be followed by <em>zero or more</em> phrases of that shape. We will get to handling multiple binary operators in our expressions in the next post in this series.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>expression :: formula ((AND | OR | IFSO) formula)?
formula :: (NOT)? term
term :: TRUE | FALSE
</pre></td></tr></tbody></table>
</div>

<p>So, our grammar states that a valid expression in our language is:</p>

<ul>
  <li>composed of at least one formula
    <ul>
      <li>which has zero or one negation operators followed by one term
        <ul>
          <li>which is either a true or false token</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>optionally followed by zero or one predicates
    <ul>
      <li>which has one of three possible operators followed by one formula</li>
    </ul>
  </li>
</ul>

<p>Now, this isn’t the most complicated or flexible grammar, but it is a valid grammar and it does encode the possible range of expressions in our tests from the start. Over this series of posts, we will expand on this grammar, but for now, let’s write the parser code for this grammar.</p>

<p>Our parser begins life with a stream of tokens, but we need to work through this stream one token at a time; so, we need a way to iterate through the stream of tokens in a controlled manner. We cannot simply call <code>#each</code> on the stream of tokens because we need to build our abstract syntax tree recursively. So, let’s implement our own iterator that will use a pointer for the current token that we will manually increment through the stream of tokens.</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
    <span class="vi">@tokens</span> <span class="o">=</span> <span class="n">tokens</span>
    <span class="vi">@stream</span> <span class="o">=</span> <span class="vi">@tokens</span><span class="p">.</span><span class="nf">to_enum</span>
    <span class="vi">@current_token</span> <span class="o">=</span> <span class="vi">@stream</span><span class="p">.</span><span class="nf">next</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">eat</span><span class="p">(</span><span class="n">token_type</span><span class="p">)</span>
    <span class="k">raise</span> <span class="k">unless</span> <span class="vi">@current_token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="n">token_type</span>

    <span class="k">begin</span>
      <span class="vi">@current_token</span> <span class="o">=</span> <span class="vi">@stream</span><span class="p">.</span><span class="nf">next</span>
    <span class="k">rescue</span> <span class="no">StopIteration</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>To achieve our desired result, we are going to use Ruby’s <a href="https://rossta.net/blog/what-is-enumerator.html"><code>Enumerator</code> infrastructure</a>. Our <code>@stream</code> will be an enumerator object that we can manually iterate over, one token at a time, using the <code>#next</code> method. Our <code>Parser#eat</code> method will be the internal mechanism we use to move the pointer (<code>@current_token</code>) to the next token in our stream (with one extra bit of safety–only moving the pointer forward if the current token is of the type specified when the method is called).</p>

<p>With a mechanism in place for manually iterating through the stream of tokens, let’s start encoding our grammar rules. The lowest level, and simplest, rule is the <code>term</code> rule, so let’s start by writing a method for this rule:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>

  <span class="c1"># term :: TRUE | FALSE</span>
  <span class="k">def</span> <span class="nf">term</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:TRUE</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:TRUE</span><span class="p">)</span>
      <span class="k">return</span> <span class="no">AST</span><span class="o">::</span><span class="no">Atom</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:FALSE</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:FALSE</span><span class="p">)</span>
      <span class="k">return</span> <span class="no">AST</span><span class="o">::</span><span class="no">Atom</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="s2">"</span><span class="si">#{</span><span class="n">token</span><span class="p">.</span><span class="nf">value</span><span class="si">}</span><span class="s2"> is an invalid term"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>This code should be fairly straightforward. We inspect the current token and if it is a <code>:TRUE</code> type token, we move the current token point up and return an operand AST node with the Boolean <code>true</code> value; whereas if the current token is a <code>:FALSE</code> type token, we move the pointer up and return an operand AST node with the <code>false</code> value; otherwise, we raise an error.</p>

<p>Next, we need a method to handle our <code>formula</code> rule:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>

  <span class="c1"># formula :: (NOT)? term</span>
  <span class="k">def</span> <span class="nf">formula</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:NOT</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:NOT</span><span class="p">)</span>
      <span class="k">return</span> <span class="no">AST</span><span class="o">::</span><span class="no">Negation</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">term</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Here, we either wrap a call to <code>term</code> in a negation AST node (if the current token is a <code>:NOT</code> type), or we simply return the <code>term</code> unwrapped.<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup></p>

<p>Finally, let’s implement the <code>expression</code> rule:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>

  <span class="c1"># expression : formula ((AND | OR | IFSO) formula)?</span>
  <span class="k">def</span> <span class="nf">expression</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">formula</span>
    <span class="n">token</span> <span class="o">=</span> <span class="vi">@current_token</span>

    <span class="k">if</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:AND</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:AND</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Conjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:OR</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:OR</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Disjunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">token</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:IFSO</span>
      <span class="n">eat</span><span class="p">(</span><span class="ss">:IFSO</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">AST</span><span class="o">::</span><span class="no">Implication</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">result</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>This method begins by setting a temporary <code>result</code> variable to the output of the <code>Parser#formula</code> method (since every expression must begin with one valid formula). We then check if the current token (which has been updated by the call to <code>Parser#formula</code>) is one of the three operator types; if it is, we move the current token pointer forward and then update that <code>result</code> variable to be the proper AST operator node, where the left hand operand is the previous <code>result</code> and the right hand operand is the result of a new call to the <code>Parser#formula method</code>. Once these checks are all done, we return the final <code>result</code>.</p>

<p>With our grammar now fully and properly encoded in our parser, we can finally implement the <code>Parser#parse</code> method. Luckily, this part is extremely simple, as a parsed stream of tokens is simply an expression:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Parser</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">parse</span>
    <span class="n">expression</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<hr />

<h3 id="the-interpreter">The Interpreter</h3>

<p>With our <code>Lexer</code> and <code>Parser</code> now implemented, we have a pipeline for converting a string representation of a basic expression of propositional logic into an abstract syntax tree object that represents that exact same expression. The final piece of the puzzle is the interpreter that will actually take our abstract syntax tree object and calculate the Boolean output of that expression.</p>

<p>The question becomes, how do we work with our abstract syntax tree to evaluate an output? Well, let’s start by thinking through what our abstract syntax tree <em>encodes</em>. Let’s work with the expression from earlier, <code>~T &amp; F</code>. Represented as a tree, we would have:</p>

<div class="tree">
  <ul>
    <li>
      <a href="#" class="monospace bg-lightgrey font-1em bold">&amp;</a>
      <ul>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">~</a>
          <ul>
            <li>
              <a href="#" class="monospace bg-lightgrey font-1em bold">T</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">F</a>
        </li>
      </ul>
    </li>
  </ul>
</div>

<p>How would we interpret this statement properly ourselves? We would take the first value—<code>T</code> for <code>true</code>— and negate it; this would give us a value of <code>false</code>. We would then compute the result of the expression <code>F &amp; F</code>, which, given the truth table for the conjunction operator, would give us <code>false</code>. Simple enough. Now, how could we do something essentially the same as this in code?</p>

<p>Well, what is it precisely that we did when we “processed” this expression ourselves? We started with values, applied operators to get new values, and followed this process until we had no more operators left, and thus only a value. We need to do the same thing with the abstract syntax tree. Let’s go ahead and translate our tree just above into a visual representation of our abstract syntax tree for this expression:</p>

<div class="tree">
  <ul>
    <li>
      <a href="#" class="monospace bg-lightgrey font-1em bold">AST::Conjunction</a>
      <ul>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">AST::Negation</a>
          <ul>
            <li>
              <a href="#" class="monospace bg-lightgrey font-1em bold">AST::Atom(true)</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="#" class="monospace bg-lightgrey font-1em bold">AST::Atom(false)</a>
        </li>
      </ul>
    </li>
  </ul>
</div>

<p>Let’s start at the bottom of this tree and walk through the basics of how to interpret an object like this. Starting with the left hand side of the conjunction, we have a negation operator applied to a true value operand. We know that we need the left hand side of the conjunction to be a value operand before we can evaluate it, so we first need to evaluate the negation operator. When looking at the negation operator node we see that it has only the one child node, only the one operand. To evaluate the operand, we simply need to get its value. With that node evaluated, we next simply need to apply the logic of negation on that value to generate a new value (<code>true</code> becomes <code>false</code> when negated). We now have a value for the left hand side of the conjunction. On the right hand side, we already have a value operand. So, we can simply evaluate the conjunction now; what is the output when the left hand side is <code>false</code> and the right hand side is <code>false</code>? Also <code>false</code>. That is our output.</p>

<p>What we are doing is essentially “visiting” each node in our tree, recursively and one at a time. When we visit a node, we first check what type of node it is. If it is an operand type of node, we simply extract its value. If it is a unary operator node (like negation), we visit its one operand node. If it is a binary operator node (like conjunction), we visit its left operand node and its right operand node. These visits just restart the process, but for that new node (this is what makes the process recursive). In fact, this process of making our way through the hierarchical abstract syntax tree is a well-worn pattern in programming, called the <a href="https://sourcemaking.com/design_patterns/visitor">Visitor pattern</a>.</p>

<p>With a firmer understanding of <em>how</em> our <code>Interpreter</code> is going to interpret the expression represented by the abstract syntax tree passed into it, let’s get started actually writing the code.</p>

<p>First, we need an initializer that will take the abstract syntax tree that our interpreter needs to evaluate as well as the primary public method for this class, the <code>Interpreter#interpret</code> method.</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Interpreter</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="vi">@ast</span> <span class="o">=</span> <span class="n">ast</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">interpret</span>
    <span class="c1"># this is where the magic will happen</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Next, we need to start implementing our “visitor” pattern. Let’s start with the simplest type of node, the operand node, and write a visitor method for that. As we said above, all this method needs to do is extract the value from the node:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Interpeter</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">visit_atom</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">node</span><span class="p">.</span><span class="nf">value</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>We only have one unary operator, negation, so let’s write a visitor method for that next. In our description above, we said that we need to visit this node’s operand child node and then flip the Boolean value. This leads us to our first issue: how do we determine which visitor method to use when visiting the operand child node? Well, we need to check the type of the node. So let’s do that:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Interpeter</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">visit_negation</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">operand_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nf">operand</span>
    <span class="n">operand_value</span> <span class="o">=</span> <span class="k">if</span> <span class="n">operand_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Atom</span>
                      <span class="n">visit_atom</span><span class="p">(</span><span class="n">operand_node</span><span class="p">)</span>
                    <span class="k">elsif</span> <span class="n">operand_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Negation</span>
                      <span class="n">visit_negation</span><span class="p">(</span><span class="n">operand_node</span><span class="p">)</span>
                    <span class="k">elsif</span> <span class="n">operand_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Conjunction</span>
                      <span class="n">visit_conjunction</span><span class="p">(</span><span class="n">operand_node</span><span class="p">)</span>
                    <span class="k">elsif</span> <span class="n">operand_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Disjunction</span>
                      <span class="n">visit_disjunction</span><span class="p">(</span><span class="n">operand_node</span><span class="p">)</span>
                    <span class="k">elsif</span> <span class="n">operand_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Implication</span>
                      <span class="n">visit_implication</span><span class="p">(</span><span class="n">operand_node</span><span class="p">)</span>
                    <span class="k">end</span>

    <span class="k">case</span> <span class="n">operand_value</span>
    <span class="k">when</span> <span class="kp">true</span>
      <span class="kp">false</span>
    <span class="k">when</span> <span class="kp">false</span>
      <span class="kp">true</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>We first figure out what kind of node the <code>node.operand</code> child node is, then we use the proper visitor method for that node type to get the value of that node. With the value, we can then implement the logic to flip the Boolean value.</p>

<p>Next, let’s try the first of our binary operators–conjunction. Our visitor method needs to do essentially the same thing as the negation visitor, just with two child nodes:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Interpeter</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">visit_conjunction</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">left_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nf">left</span>
    <span class="n">left_value</span> <span class="o">=</span> <span class="k">if</span> <span class="n">left_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Atom</span>
                      <span class="n">visit_atom</span><span class="p">(</span><span class="n">left_node</span><span class="p">)</span>
                    <span class="k">elsif</span> <span class="n">left_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Negation</span>
                      <span class="n">visit_negation</span><span class="p">(</span><span class="n">left_node</span><span class="p">)</span>
                    <span class="k">elsif</span> <span class="n">left_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Conjunction</span>
                      <span class="n">visit_conjunction</span><span class="p">(</span><span class="n">left_node</span><span class="p">)</span>
                    <span class="k">elsif</span> <span class="n">left_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Disjunction</span>
                      <span class="n">visit_disjunction</span><span class="p">(</span><span class="n">left_node</span><span class="p">)</span>
                    <span class="k">elsif</span> <span class="n">left_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Implication</span>
                      <span class="n">visit_implication</span><span class="p">(</span><span class="n">left_node</span><span class="p">)</span>
                    <span class="k">end</span>
    <span class="n">right_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nf">right</span>
    <span class="n">right_value</span> <span class="o">=</span> <span class="k">if</span> <span class="n">right_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Atom</span>
                      <span class="n">visit_atom</span><span class="p">(</span><span class="n">right_node</span><span class="p">)</span>
                    <span class="k">elsif</span> <span class="n">right_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Negation</span>
                      <span class="n">visit_negation</span><span class="p">(</span><span class="n">right_node</span><span class="p">)</span>
                    <span class="k">elsif</span> <span class="n">right_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Conjunction</span>
                      <span class="n">visit_conjunction</span><span class="p">(</span><span class="n">right_node</span><span class="p">)</span>
                    <span class="k">elsif</span> <span class="n">right_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Disjunction</span>
                      <span class="n">visit_disjunction</span><span class="p">(</span><span class="n">right_node</span><span class="p">)</span>
                    <span class="k">elsif</span> <span class="n">right_node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Implication</span>
                      <span class="n">visit_implication</span><span class="p">(</span><span class="n">right_node</span><span class="p">)</span>
                    <span class="k">end</span>

    <span class="k">case</span> <span class="p">[</span><span class="n">left_value</span><span class="p">,</span> <span class="n">right_value</span><span class="p">]</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">false</span><span class="p">,</span> <span class="kp">false</span><span class="p">]</span>
      <span class="kp">false</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">false</span><span class="p">,</span> <span class="kp">true</span><span class="p">]</span>
      <span class="kp">false</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">true</span><span class="p">,</span> <span class="kp">false</span><span class="p">]</span>
      <span class="kp">false</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">true</span><span class="p">,</span> <span class="kp">true</span><span class="p">]</span>
      <span class="kp">true</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Here we see a clear opportunity for refactoring to clean this all up a bit. Instead of putting the logic to determine which visitor method to use based on the kind of node <em>inside</em> of each specific visitor method itself, let’s pull that out into its own separate method. This method will be the sort-of switchboard for all of our specific visitor methods; and each of our specific visitor methods can focus simply on the logic for converting their child nodes into a value:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Interpreter</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Atom</span>
      <span class="n">visit_atom</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Negation</span>
      <span class="n">visit_negation</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Conjunction</span>
      <span class="n">visit_conjunction</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Disjunction</span>
      <span class="n">visit_disjunction</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">node</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">AST</span><span class="o">::</span><span class="no">Implication</span>
      <span class="n">visit_implication</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">visit_negation</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="nf">operand</span><span class="p">)</span>
    <span class="k">when</span> <span class="kp">true</span>
      <span class="kp">false</span>
    <span class="k">when</span> <span class="kp">false</span>
      <span class="kp">true</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">visit_conjunction</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">case</span> <span class="p">[</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="nf">left</span><span class="p">),</span> <span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="nf">right</span><span class="p">)]</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">false</span><span class="p">,</span> <span class="kp">false</span><span class="p">]</span>
      <span class="kp">false</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">false</span><span class="p">,</span> <span class="kp">true</span><span class="p">]</span>
      <span class="kp">false</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">true</span><span class="p">,</span> <span class="kp">false</span><span class="p">]</span>
      <span class="kp">false</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">true</span><span class="p">,</span> <span class="kp">true</span><span class="p">]</span>
      <span class="kp">true</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Much nicer! The process for writing the other binary operator visitor methods would be the same as the conjunction method, just with different logic for evaluating a Boolean value:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Interpreter</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">visit_disjunction</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">case</span> <span class="p">[</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="nf">left</span><span class="p">),</span> <span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="nf">right</span><span class="p">)]</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">false</span><span class="p">,</span> <span class="kp">false</span><span class="p">]</span>
      <span class="kp">false</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">false</span><span class="p">,</span> <span class="kp">true</span><span class="p">]</span>
      <span class="kp">true</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">true</span><span class="p">,</span> <span class="kp">false</span><span class="p">]</span>
      <span class="kp">true</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">true</span><span class="p">,</span> <span class="kp">true</span><span class="p">]</span>
      <span class="kp">true</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">visit_implication</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">case</span> <span class="p">[</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="nf">left</span><span class="p">),</span> <span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="nf">right</span><span class="p">)]</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">false</span><span class="p">,</span> <span class="kp">false</span><span class="p">]</span>
      <span class="kp">true</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">false</span><span class="p">,</span> <span class="kp">true</span><span class="p">]</span>
      <span class="kp">true</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">true</span><span class="p">,</span> <span class="kp">false</span><span class="p">]</span>
      <span class="kp">false</span>
    <span class="k">when</span> <span class="p">[</span><span class="kp">true</span><span class="p">,</span> <span class="kp">true</span><span class="p">]</span>
      <span class="kp">true</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Finally, with our visitor pattern all built out, we simply need to wire up the <code>Interpreter#interpret</code> method. Since our abstract syntax tree is simply a hierarchical, complex object—that is, it is a single node object that nests various levels of complexity within its children nodes—, we simply need to visit the tree object itself:</p>

<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Interpreter</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">interpret</span>
    <span class="n">visit</span><span class="p">(</span><span class="vi">@ast</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>With that, we have a proper interpreter for working with simple expressions of propositional logic! Congrats on sticking with it this far. If you have been writing this in a file on your own computer, you can run the tests we defined at the outset and see that our interpreter works precisely as expected. Awesome!</p>

<hr />

<h3 id="wrapping-up">Wrapping Up</h3>

<p>So, what all have we accomplished? We have written a <code>Lexer</code> that takes an input string representing a basic logical expression and converts it into a stream of <code>Token</code> objects that represent the atomic components of the expression. We wrote a <code>Parser</code> that takes such a stream of tokens and builds an abstract syntax tree to represent the expression based on a grammar that properly and fully describes the shape of our language. We finally built an <code>Interpreter</code> that takes an abstract syntax tree representation of a logical expression and evaluates its Boolean result.</p>

<p>Along the way, we learned the basics of <em>propositional logic</em>: its four basic operators, its two operand values, the truth tables for each operator, and the grammar of our simple subset of the language. We also learned what <em>tokens</em> are and how they are used in <em>lexical analysis</em>. We learned what a <em>grammar</em> is, how we can define a grammar using <em>rules</em>, and how to encode those rules in a <em>parser</em>. We then learned what an <em>abstract syntax tree</em> is, how to structure one, and how to evaluate one using the <em>visitor pattern</em>.</p>

<p>All in all, we have worked through a <strong>ton</strong> of important and interesting material. I feel pretty accomplished, and so should you.</p>

<p>In the next post, we are going to expand our grammar to allow for grouped expressions (e.g. <code>~(T v F)</code>), to allow multiple binary operators (e.g. an expression like <code>T &amp; F v T</code>), to handle operator precedence (<code>T &amp; F v T</code> should be read as <code>(T &amp; F) v T</code>, not <code>T &amp; (F v T)</code>), and to handle stacked negations (e.g. <code>~~T</code>). Hope you’ll be back to dive into that when it gets published.</p>

<blockquote>
  <p>You can find the script we have built to this point in <a href="https://gist.github.com/fractaledmind/a072674b18086fdebf3b3a535c0f7dfb/09e7c7c28c71823f7611e8d1597a8758350cc9f2">this Gist</a></p>
</blockquote>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>I have covered most of this in a section of a previous article: <a href="http://fractaledmind.com/articles/conjunctive-binarism/#a-primer-on-propositional-logic">A Primer on Propositional Logic</a> <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>The <code>:IFSO</code> type does not have a corollary in the set of logic gates. This is a constant that I made up to fit the basic semantic pattern. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Our code here can be quite simple like this since our grammar specifies that a <code>formula</code> is optionally preceeded by <em>zero or one</em> negation operators. If our grammar allowed for <em>zero or more</em> negation operators, we would have to change this code fairly significantly. This will be one of the ways in which we evolve our grammar and thus our interpreter in this series of posts. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>
</div>

    </div>

    <aside id="sidebar">

  <hr class="fractal">

  <div id="recent-articles">
    <h5>Recent Posts</h5>
    <ul class="fa-ul">
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../safely-accessing-values-from-a-nested-hash-again/">Safely Accessing Values from Nested Hashes (again)'</a>
        </li>
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../basic-restful-filtering-with-rails/">Basic RESTful Filtering with Rails</a>
        </li>
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../css-tree-vertical/">Building Pure CSS Trees (part 2)</a>
        </li>
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../css-tree/">Building Pure CSS Trees (part 1)</a>
        </li>
        <li>
          <i class="fa-li fa fa-chevron-right"></i>
          <a href="../what-is-mvc/">What is MVC?</a>
        </li>
    </ul>
  </div>

  <hr class="fractal">

  <div id="all-tags">
    <h5><a href="../../topics/">Topics</a></h5>
    <ul class="list-none">
      <!-- Add all Article tags -->
        <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="epistemology-tag" href="/topics/epistemology/">epistemology</a>
            <a class="math-tag" href="/topics/math/">math</a>
        </li>
        <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="epistemology-tag" href="/topics/epistemology/">epistemology</a>
            <a class="logic-tag" href="/topics/logic/">logic</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="pdf-workflow-tag" href="/topics/pdf-workflow/">pdf-workflow</a>
        </li>
        <li class="breadcrumb">
            <a class="prose-tag" href="/topics/prose/">prose</a>
            <a class="self-tag" href="/topics/self/">self</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="ruby-tag" href="/topics/ruby/">ruby</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="rails-tag" href="/topics/rails/">rails</a>
        </li>
        <li class="breadcrumb">
            <a class="poetry-tag" href="/topics/poetry/">poetry</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="algorithms-tag" href="/topics/algorithms/">algorithms</a>
        </li>
        <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="faith-tag" href="/topics/faith/">faith</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="git-tag" href="/topics/git/">git</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="git-tag" href="/topics/git/">git</a>
        </li>
        <li class="breadcrumb">
            <a class="prose-tag" href="/topics/prose/">prose</a>
            <a class="relationships-tag" href="/topics/relationships/">relationships</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="css-tag" href="/topics/css/">css</a>
            <a class="trees-tag" href="/topics/trees/">trees</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="css-tag" href="/topics/css/">css</a>
            <a class="trees-tag" href="/topics/trees/">trees</a>
        </li>
        <li class="breadcrumb">
            <a class="poetry-tag" href="/topics/poetry/">poetry</a>
            <a class="relationships-tag" href="/topics/relationships/">relationships</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="css-tag" href="/topics/css/">css</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="http-tag" href="/topics/http/">http</a>
        </li>
        <li class="breadcrumb">
            <a class="prose-tag" href="/topics/prose/">prose</a>
            <a class="life-tag" href="/topics/life/">life</a>
        </li>
        <li class="breadcrumb">
            <a class="prose-tag" href="/topics/prose/">prose</a>
            <a class="faith-tag" href="/topics/faith/">faith</a>
        </li>
        <li class="breadcrumb">
            <a class="philosophy-tag" href="/topics/philosophy/">philosophy</a>
            <a class="ethics-tag" href="/topics/ethics/">ethics</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="ruby-tag" href="/topics/ruby/">ruby</a>
            <a class="interpreter-tag" href="/topics/interpreter/">interpreter</a>
        </li>
        <li class="breadcrumb">
            <a class="tutorial-tag" href="/topics/tutorial/">tutorial</a>
            <a class="interpreter-tag" href="/topics/interpreter/">interpreter</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="mvc-tag" href="/topics/mvc/">mvc</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="latin-tag" href="/topics/latin/">latin</a>
            <a class="vergil-tag" href="/topics/vergil/">vergil</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="epicurus-tag" href="/topics/epicurus/">epicurus</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="aristotle-tag" href="/topics/aristotle/">aristotle</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="latin-tag" href="/topics/latin/">latin</a>
            <a class="horace-tag" href="/topics/horace/">horace</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="modern-tag" href="/topics/modern/">modern</a>
            <a class="lewis-tag" href="/topics/lewis/">lewis</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="modern-tag" href="/topics/modern/">modern</a>
            <a class="barfield-tag" href="/topics/barfield/">barfield</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="herodotus-tag" href="/topics/herodotus/">herodotus</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="hippocrates-tag" href="/topics/hippocrates/">hippocrates</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="greek-tag" href="/topics/greek/">greek</a>
            <a class="plato-tag" href="/topics/plato/">plato</a>
        </li>
        <li class="breadcrumb">
            <a class="academia-tag" href="/topics/academia/">academia</a>
            <a class="modern-tag" href="/topics/modern/">modern</a>
            <a class="saussure-tag" href="/topics/saussure/">saussure</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="alfred-tag" href="/topics/alfred/">alfred</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="bash-tag" href="/topics/bash/">bash</a>
        </li>
        <li class="breadcrumb">
            <a class="code-tag" href="/topics/code/">code</a>
            <a class="python-tag" href="/topics/python/">python</a>
        </li>
    </ul>
  </div>
</aside>


    <footer role="contentinfo">
  <div class="footer-info">
    <p>&copy; Copyright 2015 by Stephen Margheim</p>
    <p>Powered by <a href="https://middlemanapp.com">Middleman</a>.</p>
  </div>
</footer>


  </body>
</html>
